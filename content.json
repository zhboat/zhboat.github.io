{"meta":{"title":"柚子的随记","subtitle":"","description":"","author":"柚木舟","url":"https://zhboat.ink","root":"/"},"pages":[{"title":"关于","date":"2020-11-14T05:12:32.205Z","updated":"2020-11-14T05:12:32.205Z","comments":true,"path":"about/index.html","permalink":"https://zhboat.ink/about/index.html","excerpt":"","text":"这已经是柚子的第不知道多少个博客了,之前皆以脑手残rm -rf没了下文,这次本站大概率会永久存在了(除非我不想续费域名了) 关于咱至此存活世间20载 懒癌晚期极简主义者 拖延症非常非常严重 低自制力,低理解力 大概是无药可救了吧 混迹这么久之后,啥都懂点,但却又啥都不懂 文章大多以参考以及记录为主(怕自己忘记) 联系咱QQ:2641824591 TG:zhboat Email:zhboat@163.com 友链友链是啥东西?鉴于本人太懒了,本来是没打算搞这个的,到下面留言,咱不小心点开自己的博客看到了就会添加上去的"},{"title":"所有标签","date":"2020-11-14T05:12:32.209Z","updated":"2020-11-14T05:12:32.209Z","comments":true,"path":"tags/index.html","permalink":"https://zhboat.ink/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"随记","slug":"随记","date":"2020-11-13T16:29:21.000Z","updated":"2020-11-14T05:12:32.205Z","comments":true,"path":"随记/","link":"","permalink":"https://zhboat.ink/%E9%9A%8F%E8%AE%B0/","excerpt":"苹果在11月13号凌晨推送了Big Sur正式版,拖延许久的我为此忙了一下午…","text":"苹果在11月13号凌晨推送了Big Sur正式版,拖延许久的我为此忙了一下午… 这周因种种事情,导致很早之前就想更新oc的我直至今天才更新 新买的固态也早早就收货了,以史低价399拿到了500G的西数750,也不枉我觊觎良久 难得周五这天有空,于是开始下载新版镜像重新安装 起初其实是打算备份还原来着,想到臃肿的环境和自己错误配置导致系统的小bug,想了想便算罢了 软件大体倒是不必重新下载,从旧硬盘直接复制到新硬盘就行 设置各个软件费了我许久的时间,真真是被我强迫症害了 把软件搞完后一边水群一边完善和更新oc版本 将博客通过Action重新构建确实挺有先见的,以hexo繁琐的架构迁移一次估计得非老劲 将博客文件夹复制后只需在新系统上装个git就能用了,变相地节省了电脑性能(?) 麻烦之处在于得重新部署密钥 罢了罢了,时辰不早了,睡也","categories":[],"tags":[{"name":"日常","slug":"日常","permalink":"https://zhboat.ink/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"1024","slug":"程序员节","date":"2020-10-24T06:54:20.000Z","updated":"2020-11-14T05:12:32.205Z","comments":true,"path":"程序员节/","link":"","permalink":"https://zhboat.ink/%E7%A8%8B%E5%BA%8F%E5%91%98%E8%8A%82/","excerpt":"节日快乐,编码有成!","text":"节日快乐,编码有成!","categories":[],"tags":[{"name":"日常","slug":"日常","permalink":"https://zhboat.ink/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"Python入门笔记","slug":"Python入门笔记","date":"2020-09-28T11:04:20.000Z","updated":"2020-11-14T05:12:32.205Z","comments":true,"path":"Python入门笔记/","link":"","permalink":"https://zhboat.ink/Python%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/","excerpt":"Python","text":"Python 输入输出 标准输出 语法print(&#39;&#39;,[sep = &#39; &#39;],[end = &#39;\\n&#39;],[file = None]) 123456print(sep&#x3D;&#39; &#39;,输入多个内容的时候，使用的分割符end&#x3D;&#39;\\n&#39;, 输出默认的结尾是什么--\\n--换行符file&#x3D;None，将输出的内容从控制台编程输出到文件中--了解 ) 标准输入 语法input() 1input('这是一条输入语句') 通过键盘输入一些内容 变量变量名只包含数字,字母,下划线 不能以关键字命名 不能以数字开头 PEP8命名规范 1.恒定量(常量)使用全大写与下划线:比如规定的不可更改的变量的值 2.私有变量使用前导下划线和小写,如:_message 3.一般的变量则应该: 全小写,用下划线隔开 表示类型的字母放在最前面 作用或要完成的工作则在中间 属于谁 放在最后,或可省略 例如: numpy_creat_data_set_test表示的意思是: 该变量是Numpy类型,被创建为一个数据 集,用于测试(test这个函数的内部变量) _ 4.当一个变量被用于保存于布尔值时,做好使用is或has作为前缀,这样更易于理解 5.当一个变量被用于保存序列时,最好使用复数形式 6.当一个变量被用于临时保存时,最好加上temp_的前缀 7.当一 个变量被用于作为字典时,应该使用显示名称,如一个用来保存个人地址的变量:person_address 8.应当避免使用通用 名称,现有名称(已有名称,变量i,j可以循环使用), 避免关键字,非得使用可以使用后缀下划线 9.类名使用驼峰命名法,当 定义的是模块的私有类时,还可能有一个前导下划线。 变量名全小写,单词使用下划线分隔 表示类型的字母放在最前面 作用或要完成的工作放在中间 属于谁放在最后,或可省略 数据类型基本数据类型基础类型可以分为四个类型 数值类型的复杂度是bool &lt; int &lt; float 在混合类型的表达式中，Python首先将被操作的对象(数字)转换成其中最复杂的操作对象(数字)的类型，然后再 对相同类型的操作对象(数字)进行数学运算 使用type(变量名)查看变量类型 整型(Int) Python对于整型的定义只有int类型 数值一般为十进制,也可以表示成二进制,八进制,十六进制 二进制: 以0b或0B开头,后面是二进制数01010 八进制: 以0o或0O开头,后面是八进制数0 ~ 7 十六进制: 以0x或0X开头,后面是十六进制数0 ~ 9 ,a ~ f 或 A ~ F 在编译运行的时候会自动转换成十进制数 例如int_age = 15 那么type(age)的结果就是int 浮点(Float) Python对于浮点数的定义只有float类型 可以省略小数点前或后的0 取值范围是-10 ^ 308 ~ 10 ^ 308,如若超过取值范围会出现溢出错误 布尔(Bool) 也称作逻辑常量,只有True和False两个值 其False对应0,True对应非0值(1) 复数(Complex) 表示方式为实部 + 虚部,其虚部以j 或 J作结尾 可以使用complex()函数创建复数 复数的运算(2 + 3j) + (2 + 1j)的值是4 + 4j 组合数据类型组合数据是存储多个基本数据类型的一种数据结构 列表(list) 列表中的元素类型可以是相同的也可以是不同的 列表中的元素既可以是基本数据类型也可以是组合数据类型 语法格式:列表名[元素1,元素2,元素3,元素4] 例:names = [&#39;张三&#39;,&#39;李四&#39;,&#39;王五&#39;] 其数据类型是:&lt;class &#39;list&#39;&gt; 字典(dict) 如有key : value组合的数据类型可以使用字典进行储存 字典的key不能重复 语法格式:字典名 = {key1:value1,key2:value2} 例:user_info = &#39;姓名&#39;:&#39;张三&#39;,&#39;年龄&#39;:&#39;20&#39; 其数据类型是&lt;class &#39;dict&#39;&gt; 元组(tuple) 语法格式:元组名 = (&#39;张三&#39;,&#39;李四&#39;,&#39;王五&#39;) 集合(set) 无序的,唯一的,不可变类型 集合中的元素不保存存储的顺序 集合中的元素是不能重复的 集合中的元素是无法被修改的 语法格式:集合名 = {&#39;张三&#39;,&#39;李四&#39;,&#39;王五&#39;} 运算符 运算符 描述 示例(a = b = 5) + 加号 两个对象相加 a+b 的结果为10 - 减号 取一个数的负数,或一个数减去另一个数 a - b的结果为-10 * 乘号 两个数相乘或返回一个被重复n次的字符串 a * b的结果为25 ** 幂运算 返回a的b次幂,即5^5的结果是3125 / 除号 返回a除以b的结果1.0 返回包含任何余数的浮点结果 // 真除运算(floor) 返回a除以b的结果1 若两数为int则返回int 否则为float类型 % 取余 返回除法的余数a % b的结果为0 对于字符串而言,加法的操作是让两个字符串连接,乘法的操作是让字符串重复输出n次 字符串无法做减法运算,除法运算 12345678910111213141516# 判断12是否为偶数x = 12if x % 2 == 0: print(\"x为偶数\")else: print(\"x为奇数\") # 逆序输出任意三位数y = 123# 取个位数t1 = y % 10# 去十位数t2 = y // 10 % 10# 去百位数t3 = y // 100print(t1 * 100 + t2 * 10 + t3) 逻辑运算符短路运算:一旦前面的表达式可以完成整个表达式关系的计算,那么后续的计算就不会继续判断 在and中,只要有一个False则整个表达式的结果就是False 在or中,只要有一个True则整个表达式的结果就是True 运算符 逻辑表达式 描述 示例 and x and y 布尔”与” 如果 x 为 False，x and y 返 回 False，否则它返回 y 的计算值。 x = False y = True b = x and y print(b) or x or y 布尔”或” 如果 x 是 True，它返回 True，否则它返回 y 的计算值。 x = True y = False b = x or y print(b) not not x 布尔”非” 如果 x 为 True，返回 False。如果 x 为 False，它返回 True。 x = True b = not x print(b) 复合赋值运算符 运算符 描述 示例 += 加法赋值运算符 c += a 等效于 c = c + a -= 减法赋值运算符 c -= a 等效于 c = c - a *= 乘法赋值运算符 c *= a 等效于 c = c * a /= 除法赋值运算符 c /= a 等效于 c = c / a %= 取模赋值运算符 c %= a 等效于 c = c % a **= 幂赋值运算符 c = a 等效于 c = c a //= 取整除赋值运算符 c //= a 等效于 c = c // a 正则 匹配固定字符的元字符 标识符 含义 \\b 匹配单词的开和结束 Hello World \\d 匹配数字 \\w 匹配字母,数字,下划线 \\s 匹配任意空白,包括空格,制表符 [a-z] 匹配字符a到z之间的26个小写字母中的任意一个字母 . 匹配换行符以外的任意一个字符 表示重复次数的元字符 标识符 含义 ? 重复匹配0次到1次 * 重复匹配0次或更多次 + 重复匹配1次或更多次 {n , } 重复n次或更多次 {n , m} 重复n 到 m次 使用方法 导包 import re 将一个正则表达式编译成一个pattern对象(正则表达式规则模式对象) pattern = re.compile(&#39;正则表达式&#39;,&#39;匹配的模式&#39;,) 匹配模式: re.S 可以匹配任意字符 使用pattern对象,进行匹配文本 匹配的方法pattern.match/search/findall/sub/split 匹配方法 match方法: 默认从开头位置匹配,只匹配一次,返回match对象 12345match对象 = pattern.match( '待匹配的字符串', '匹配的开始位置', 默认为0 '匹配的结束位置', 默认就是字符串的结尾) search方法: 默认全文匹配,值匹配一次,全文都找到返回match对象,全文都没找到就返回None 12345search对象 = pattern.search( '待匹配的字符串', '匹配的开始位置', 默认就是0 '匹配的结束为止', 默认就是字符串的结尾) findall方法: 全文匹配,匹配多次,将匹配到的数据存放到一个list中返回 12345list = pattern.findall( '待匹配的字符串', '匹配的开始为止', 默认为0 '匹配的结束位置', 默认是字符串的结尾) split方法: 切分字符串 1234list = pattern.split( '切分的字符串', '切分次数', 默认是全部切分) sub方法: 替换字符串 1234str = pattern.sub( '替换的内容', 想要用啥替换 '替换的目标', 替换哪个字符串) 贪婪和非贪婪 贪婪和非贪婪表示的正则匹配次数 正则匹配模式是贪婪模式,非贪婪模式用?控制 贪婪模式下,匹配的次数取决于最大值,非贪婪模式下匹配次数取决于最小值","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://zhboat.ink/tags/Python/"}]},{"title":"C语言笔记(14)","slug":"C语言笔记-14","date":"2020-07-19T08:54:34.000Z","updated":"2020-11-14T05:12:32.205Z","comments":true,"path":"C语言笔记-14/","link":"","permalink":"https://zhboat.ink/C%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0-14/","excerpt":"课后习题","text":"课后习题 最大公约数和最小公倍数12345678910111213141516171819202122232425/*输入两个数，求最大公约数和最小公约数*/#include &lt;stdio.h&gt;int main() &#123; int a, b, x , y, t; scanf(\"%d %d\", &amp;a, &amp;b); x = a; y = b; // 交换a与b的值 if ( a &lt; b)&#123; t = b; b = a; a = t; &#125; // 当b不等于0时执行循环体语句 while( b != 0)&#123; t = a % b; a = b; // a 最后的结果为最大公约数 b = t; &#125; int i = x * y / a; // 最初值相乘除以最大公约数得到最小公倍数 printf(\"最大公约数是：%d\\n\" \"最小公约数是：%d\", a, i); return 0;&#125; 打印如下图案 123456789101112131415161718192021222324252627282930313233/* * *** ************ ***** *** * */#include &lt;stdio.h&gt;int main() &#123; for (int i = 1; i &lt;= 4; i++) &#123; // 循环次数 for (int k = 1; k &lt;= 4 - i; ++k) &#123; // 空格 printf(\" \"); &#125; for (int j = 1; j &lt;= i * 2 - 1; j++) &#123; // 星号 printf(\"*\"); &#125; printf(\"\\n\"); &#125; for (int i = 3; i &gt;= 1 ; i--) &#123; // 循环次数 for (int k = 1; k &lt;= 4 - i ; ++k) &#123; // 空格 printf(\" \"); &#125; for (int j = 1; j &lt;= i * 2 -1; ++j) &#123; // 星号 printf(\"*\"); &#125; printf(\"\\n\"); &#125; return 0;&#125; 函数实现素数123456789101112131415161718192021222324252627282930/* * 输入一个值，并传递给函数isSushu * 在函数isSushu中判断该值是否为素数*/#include &lt;stdio.h&gt;int isSushu(int x);int main() &#123; int x; scanf(\"%d\", &amp;x); // 传递参数 isSushu(x);&#125;int isSushu(int x)&#123; int i = 2,isTrue = 1; // 素数算法 while (i &lt; x) &#123; if (x % i == 0) &#123; isTrue = 0; &#125; i++; &#125; // 判断 if ( isTrue )&#123; printf(\"%d是素数\\n\", x); &#125; else &#123; printf(\"%d不是素数\", x); &#125; // 返回空值 return 0;&#125; 100以内的所有素数12345678910111213141516171819// 求100以内的素数#include &lt;stdio.h&gt;int main() &#123; for (int x = 3; x &lt;= 100; x++) &#123; int isPrime = 1; for (int i = 3; i &lt; x; i++) &#123; // 当x % i 的值为0 时 if (!(x % i)) &#123; isPrime = 0; &#125; &#125; // 如果isPrime不为0,代表这个值是素数,输出它 if (isPrime) &#123; printf(\"%d\\t\", x); &#125; &#125; return 0;&#125; 冒泡算法 - 输入十个数,将其从大到小输出1234567891011121314151617181920212223242526272829/*编写一个程序输入10个数，将其中最大的数和第一个数对换 * 最小数和最后一个数对换，输出对换后的10个数*/#include &lt;stdio.h&gt;int main() &#123; const int NUM = 11; int a[NUM], i, j, k; // 输入数据 for (i = 0; i &lt; NUM - 1; i++) &#123; scanf(\"%d\", &amp;a[i]); &#125; for (j = 0; j &lt; NUM - 1; j++) &#123; for (k = 0; k &lt; NUM - 1; k++) &#123; // 如果后者大于前者 if (a[k] &lt; a[k + 1]) &#123; // 将其往前移一位 int tmp = a[k + 1]; a[k + 1] = a[k]; a[k] = tmp; &#125; &#125; &#125; // 遍历数组并输出 for (i = 0; i &lt; NUM - 1; ++i) &#123; printf(\"%d \", a[i]); &#125; return 0;&#125; 输入 不多于五位的正整数,输出其位数,每一个数字,逆向输出1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;#include \"math.h\"int main() &#123; int x, n, tmp; scanf(\"%d\", &amp;x); // 将x的值赋给临时变量tmp tmp = x; // 输出输入数的位数 for (n = 0; tmp &gt; 0; n++) &#123; tmp /= 10; &#125; printf(\"它是%d位数\\n\", n); // 挨个输出x的值 printf(\"每一个数字是:\"); for (int i = n; i &gt; 0; i--) &#123; int t = (int) (x / pow(10, i - 1)); printf(\"%d \", t % 10); &#125; // 逆向输出x的值 printf(\"\\n逆向输出结果是:\"); for (int j = 0; j &lt; n; j++) &#123; int t = x % 10; printf(\"%d\", t); x /= 10; &#125;&#125; 输入一串字符,统计英文,空格,数字,其他字符数量1234567891011121314151617181920212223/*输入一行字符，分别统计出其中英文字母，空格，数字和其他字符的个数*/#include &lt;stdio.h&gt;int main() &#123; char c; int letter = 0, space = 0, num = 0, other = 0; while ((c = getchar()) != '\\n') &#123; // 统计英文个数 if (c &gt;= 'A' &amp;&amp; c &lt;= 'Z' || c &gt;= 'a' &amp;&amp; c &lt;= 'z') &#123; letter++; // 统计空格个数 &#125; else if (c == ' ') &#123; space++; // 统计数字个数 &#125; else if (c &gt;= '0' &amp;&amp; c &lt;= '9') &#123; num++; // 统计其他字符个数 &#125; else other++; &#125; printf(\"英文有：%d个\\n空格有：%d个\\n\" \"数字有%d个\\n其他字符有%d个\", letter, space, num, other);&#125; 求x + xx + xxx + xxxx +… = S ^ n1234567891011121314#include &lt;stdio.h&gt;int main() &#123; int i, temp = 0, sum = 0, t; scanf(\"%d\", &amp;i); t = i; for (int j = 1; j &lt;= t; j++) &#123; temp += i; sum += temp; i *= 10; &#125; printf(\"%d\\n\", sum); return 0;&#125; 求∑ (n = 1到20) n !123456789101112131415// 1! + 2! + 3! + 20!#include &lt;stdio.h&gt;int main() &#123; double fact = 1, sum = 1; for (int i = 1; i &lt;= 20; i++) &#123; // 阶乘的值 fact *= i; // 各个阶乘值相加 sum += fact; &#125; // 以指数形式输出，并精确到小数点后15位 printf(\"%.15e\", sum); return 0;&#125; 输入三个字符串,求最大的一个123456789101112131415161718192021222324/* 有三个字符串,要求找出其中最大者 */#include &lt;stdio.h&gt;#include \"string.h\"int main() &#123; // 定义一个二维字符串数组x,三列字符长度均20 char x[3][20] = &#123;&#125;; // 定义一个字符变量string，存放最大者 char string[20]; // 输入三次，分别存放在x[0],x[1],x[2] for (int i = 0; i &lt; 3; ++i) &#123; gets(x[i]); &#125; // 判断，对比x[0]和x[1]的值，如果x0大于x1则将x0的值赋给string变量 if (strcmp(x[0],x[1]) &gt; 0)&#123; strcpy(string, x[0]); // 否则将x1的值赋给string变量 &#125; else strcpy(string, x[1]); // 判断，对比x[2]和string的值，如果x2大于string则将x2的值赋给string变量 if (strcmp(x[2],string) &gt; 0)&#123; strcpy(string, x[2]); &#125; printf(\"%s\", string);&#125;","categories":[],"tags":[{"name":"C","slug":"C","permalink":"https://zhboat.ink/tags/C/"}]},{"title":"C语言笔记(13)","slug":"C语言笔记-13","date":"2020-06-15T06:45:20.000Z","updated":"2020-11-14T05:12:32.205Z","comments":true,"path":"C语言笔记-13/","link":"","permalink":"https://zhboat.ink/C%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0-13/","excerpt":"位运算符","text":"位运算符 位运算符作用于位，并逐位执行操作 建议动纸笔手算便于理解 按位运算 运算符 描述 &amp; 按位与操作，按二进制位进行”与”运算 | 按位或运算符，按二进制位进行”或”运算 ~ 取反运算符，按二进制位进行”取反”运算 ^ 异或运算符，按二进制位进行”异或”运算 &amp; 对比a与b的二进制数,当重叠部分皆是1时则为1,当任其一位有差异或皆为0则为0,超出部分忽略按0处理 用于处理让某一位或某些位为0: x &amp; 254让最后一位为0 例如53 &amp; 37 12345678910先将两个数的二进制换算出来,然后进行位与运算53的二进制数是: 1 1 0 1 0 137的二进制数是: 1 0 0 1 0 1 ⇩_____⇩___⇩ 1 0 0 1 0 1 &#x2F;&#x2F; 相与后的结果 ___________ &#x2F;&#x2F; 二进制转十进制,从右向左计算(1*2^0)+(0*2^1)+(1*2^2)+(0*2^3)+(0*2^4)+(1*2^5)_______________________________________________1 + 0 + 4 + 0 + 0 + 32 &#x3D; 37 | 对比a与b的二进制数,当重叠部分皆是1或任其一位为1则为1,都是0则为0 超出部分是1则按1算 例如23 | 49 常用于让一位或几个位为1: x | 1 如论x是0还是1,或1后都是1 12345678910先将两个数的二进制换算出来,然后进行位或运算53的二进制数是: 1 0 1 1 137的二进制数是: 1 1 0 0 0 1 ⇩_⇩___⇩_⇩_⇩ 1 1 0 1 1 1 &#x2F;&#x2F; 相或后的结果 ___________ &#x2F;&#x2F; 二进制转十进制,从右向左计算(1*2^0)+(1*2^1)+(1*2^2)+(0*2^3)+(1*2^4)+(1*2^5)_______________________________________________1 + 2 + 4 + 0 + 16 + 32 &#x3D; 55 ~ 对于a的二进制数来做取反的输出,即1变成0,0变成1 例如~88 ~0 –&gt; -1 ~70 –&gt; -71 123456计算88的二进制数,让其0变1,1变088的二进制数是 0 1 0 1 1 0 0 0 做取反 1 0 1 0 0 1 1 1 其中有一位是二进制数的补码形式其最终结果就是-89 ^ 对于a与b的二进制数做按位异或的运算,如果a和b两个位相等,结果为0,否则不相等结果为1 如果a与b 的值相等,那么结果为0 对同一个变量用同一个值异或两次,将回到原值 a ^ b ^ b --&gt; a 例如32^11 12345678计算32和11的二进制数32的二进制数: 0 0 1 0 0 0 0 0 11的二进制数: 0 0 0 0 1 0 1 1 做异或: ⇩ ⇩ ⇩ ⇩ 0 0 1 0 1 0 1 1(1*2^0)+(1*2^1)+(0*2^2)+(1*2^3)+(0*2^4)+(1*2^5)+(0*2^6)+(0*2^7) _________________________________________________________________1 + 2 + 0 + 8 + 0 + 32 + 0 + 0 &#x3D; 43 移位运算 运算符 描述 &lt;&lt; 二进制左移运算符,将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃,右边补0） &gt;&gt; 二进制右移运算符,将一个数的各二进制位全部右移若干位,正数左补0,负数左补1,右边丢弃 没有移位负数这一说! &lt;&lt; a &lt;&lt; b将a的二进制数向左移动b个位置,右边多出部分补0 所有小于int的类型,移位以int的方式来做,其结果是int类型 a &lt;&lt; 1 == a *= 2, a &lt;&lt; n == a *= 2^n 例如a = 5; a &lt;&lt; 2 == a = 5*4 按照二进制计算,例如27 &lt;&lt; 4 12345678计算27的二进制数27的二进制数: 0 0 0 1 1 0 1 1 | 左移四位变成 0 0 0 1 1 0 1 1 0 0 0 0计算出左移后的值 (0*2^0)+(0*2^1)+(0*2^3)+(1*2^4)+(1*2^5)+(0*2^6)+(1*2^7)+(1*2^8)_________________________________________________________________256 + 128 + 32 + 16 &#x3D; 432 &gt;&gt; a &gt;&gt; b将a的二进制数向右移动b个位置,右边超出部分丢弃 所有小于int的类型,移位以int的方式来做,其结果是int类型 对于Unsigned类型,左边填入0,对于signed类型,左边填入原来的最高位(保持符号不变) a &gt;&gt; 1 == a /= 2, a &gt;&gt; n == x /= 2^n 例如a = 20; a &gt;&gt; 3 == a = 20/8 按照二进制计算,例如37 &gt;&gt; 2 12345678计算37的二进制数37的二进制数: 0 0 1 0 0 1 0 1 | 右移两位变成 0 0 0 0 1 0 0 1 计算出右移后的值 (1*2^0)+(0*2^1)+(0*2^3)+(1*2^4)_______________________________1 + 0 + 0 + 8 &#x3D; 9","categories":[],"tags":[{"name":"C","slug":"C","permalink":"https://zhboat.ink/tags/C/"}]},{"title":"C语言笔记(12)","slug":"C语言笔记-12","date":"2020-06-13T05:11:20.000Z","updated":"2020-11-14T05:12:32.205Z","comments":true,"path":"C语言笔记-12/","link":"","permalink":"https://zhboat.ink/C%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0-12/","excerpt":"输入输出","text":"输入输出 输入scanf %[flag] type flag 含义 * 跳过 数字 最大字符数 hh char h short l long,double ll long long L long double type 用于 d int i 整数,可能是16进制或8进制 u Unsigned int o 8进制 x 16进制 a,e,f,g float c char s 字符串(单词) p 指针 输出printf %[flags] [width] [.prec] [hlL] type flag 含义 - 左对齐 + 在前面放+或-单目运算符 空格 正数留空 0 填充0 width 含义 number 最小字符数 * 下一个参数是字符数 .number 精确小数点位数 .* 下一个参数是小数点后的位数 123456#include &lt;stdio.h&gt;int main() &#123; printf(\"%*d\", 5 ,11); // --&gt; printf(\"%5d\", 11) 右对齐5位 5可以是变量 return 0;&#125; 修饰类型 含义 hh 单个字符 h short l long ll long long L long double type 用于 – type 用于 i或者d int s float,6 c char g char G float f或F float,6 o 8进制 x 16进制 X 大写16进制 p 指针 a或A 16进制浮点 e或E 指数 u Unsigned int n 读入/写入的个数 #o 带前导8进制 #x 带前导16进制 12345678910#include &lt;stdio.h&gt;int main() &#123; int num; char *string = \"abcdefg\"; printf(\"%s%n\\n\", string, &amp;num); // 将a-g的个数通过%n传递给指针变量num printf(\"%d\", num); return 0;&#125; 文件输入输出 用&gt;和&lt;做重定向 理解成mysql和Linux就行 fopen 参数 含义 r 打开只读 r+ 打开读写,从文件开头开始 w 打开只写,如果不存在则新建,如果存在则清空 w+ 打开读写,如果不存在则新建,如果存在则清空 a 打开追加,如果不存在则新建,如果存在则从文件末尾开始 ..x 只新建,如果文件已存在则无法打开","categories":[],"tags":[{"name":"C","slug":"C","permalink":"https://zhboat.ink/tags/C/"}]},{"title":"C语言笔记(11)","slug":"C语言笔记-11","date":"2020-06-11T07:32:20.000Z","updated":"2020-11-14T05:12:32.205Z","comments":true,"path":"C语言笔记-11/","link":"","permalink":"https://zhboat.ink/C%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0-11/","excerpt":"无题","text":"无题 全局变量 定义在函数外面的变量就是全局变量 全局变量具有全局的生存期和作用域 它们与任何函数都没有关系,但是在任何函数的内部都可以使用它们 全局变量默认初始化值是0,指针变量会得到NULL值 只能用已知的值去初始化全局变量,因为它们的初始化在Main函数之前 如果函数内部存在与全局变量同名的变量,那么全局变量会被覆盖 静态本地变量 在本地变量定义时加上static修饰符就能成为静态本地变量 当函数离开的时候,静态本地变量会继续存在并保持其值 静态本地变量的初始化只会在第一次进入这个函数的时候做,以后进入函数时会保持上次离开时候的值 static是特殊的全局变量,与全局变量在内存的同一块地址,具有全局生存期,但只有局部作用域 宏 以#开头的是编译预处理指令,不是C语言自带的东西 使用#define定义宏,#define &lt;名称&gt; &lt;值&gt; 在编译前通过完整的文本替换方式将名称替换对应的值 宏可以嵌套使用,超过一行的值需要在行末加上\\ 在值中写注释不会被当作值的一部分 还有一些预定义的宏 宏 描述 _LINE_ 这会包含当前行号，一个十进制常量。 _FILE_ 这会包含当前文件名，一个字符串常量。 _TIME_ 当前时间，一个以 “HH:MM:SS” 格式表示的字符常量。 _DATE_ 当前日期，一个以 “MMM DD YYYY” 格式表示的字符常量。 _STDC_ 当编译器以 ANSI 标准编译时，则定义为 1。 1234567891011121314151617#include &lt;stdio.h&gt;int main() &#123; printf(\"File :%s\\n\", __FILE__); printf(\"Date :%s\\n\", __DATE__); printf(\"Time :%s\\n\", __TIME__); printf(\"Line :%d\\n\", __LINE__); printf(\"ANSI :%d\\n\", __STDC__);/* * File :/Users/zhboat/CLionProjects/hon/main.c * Date :Jun 14 2020 * Time :15:37:03 * Line :8 * ANSI :1*/ return 0;&#125; 带参数的宏 可以像函数一样使用,将未来的参数传递到预处理指令中 格式#define &lt;名称(参数)&gt; &lt;值&gt; 在其他函数中调用#define的名称加()时传递的值会回到#define中 使用参数的时候,整个值需要加上括号,每个使用参数的地方也需要加上括号 可以嵌套组合使用,也可以带上多个参数 #define MIN(a,b) ((a)&gt;(b)?(b):(a))判断两个数中最小的值,如果a大于b,则最小数就是b,否则就是a 1234567891011#include &lt;stdio.h&gt;#define cube(i) ((i) * (i + 1) * ( i + 2))// i = 5, i + 1 = 6, i + 2 = 7int main() &#123; int i; scanf(\"%d\", &amp;i); // i = 5 printf(\"%d\", cube(i)); // 5 * 6 * 7 = 210 return 0;&#125; #&amp;##字符串常量化运算符（#）在宏定义中，当需要把一个宏的参数转换为字符串常量时，则使用字符串常量化运算符（#）。在宏中使用的该运算符有一个特定的参数或参数列表 标记粘贴运算符（##）宏定义内的标记粘贴运算符（##）会合并两个参数。它允许在宏定义中两个独立的标记被合并为一个标记 头文件 头文件是扩展名为 .h 的文件，包含了 C 函数声明和宏定义，被多个源文件中引用共享。有两种类型的头文件：程序员编写的头文件和编译器自带的头文件。 把函数原型放到一个头文件(以.h结尾)中,在需要调用这个函数的源代码文件(.c)中#include这个头文件,就能让编译器在编译的时候知道函数的原型 #include 与宏一样,#include也是一个编译预处理指令,在编译之前就处理好了 它的作用是把头文件中的全部文本原封不动得插入到#include所在的位置 #include &quot;&quot;要求编译器首先在当前目录寻找头文件,如果没有就去其他地方寻找,#include &lt;&gt;用于引用系统头文件,在系统目录的标准列表中搜索 在使用和定义函数的地方都应该有#include 头文件,任何源文件除了main函数都应该有对应的同名头文件,把所有对外公开的函数的原型和全局变量的声明都放进去 不对外公开的函数 在函数前面加上static就能让他成为只能在所在的源代码中才能被使用的函数 声明 对于变量的声明,格式:extern 变量类型 变量名 函数原型 变量声明 结构声明 宏声明 枚举声明 类型声明 …等,这些声明都是不产生代码,只有在定义的时候才产生代码 重复声明 如果头文件中有结构的声明,那么很可能会在同一个源代码中被#include很多次,为了避免这种情况的发生,需要用到标准头文件结构 标准的做法是把文件的整个内容放在条件编译语句中 12345#ifndef 头文件#define 头文件声明...#endif 1234567#ifndef POINT_H#define POINT_Hstruct point &#123; int x; int y;&#125;;#endif","categories":[],"tags":[{"name":"C","slug":"C","permalink":"https://zhboat.ink/tags/C/"}]},{"title":"C语言笔记(10)","slug":"C语言笔记-10","date":"2020-06-09T06:40:20.000Z","updated":"2020-11-14T05:12:32.205Z","comments":true,"path":"C语言笔记-10/","link":"","permalink":"https://zhboat.ink/C%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0-10/","excerpt":"枚举 (Enumer)","text":"枚举 (Enumer) 枚举是一种用户定义基本数据类型,使用关键字enum声明,主要用于排比一系列有意义的名字 格式enum 枚举名 {枚举元素1,枚举元素2,...} 枚举元素只能是int类型,可以作为常量符号使用 枚举可以让独立定义的连续常量更简洁化 例如 1234const int zero = 0;const int one = 1;const int two = 2;const int three = 3; 可以使用枚举写成enum number{zero,one,two,three} 第一个枚举元素默认从0开始,你可以指定第一个从任意数字开始,后面依次排列 输入输出枚举的元素可以作为值去使用,而枚举类型可以带上enum作为数据类型,犹如int、double这种数据类型一样,还可以以整数的方式做内部计算和外部的输入输出 1234567891011121314#include &lt;stdio.h&gt;enum number &#123; one = 1, two, three &#125;; // 声明number类型的数据类型void f(enum number x); // 声明f函数需要一个number类型的参数int main() &#123; enum number t = 0; // 初始化number类型的临时变量t scanf(\"%d\" , &amp;t); f(t); // 传递t的值到f函数 return 0;&#125;void f(enum number x)&#123; printf(\"%d\", x); // 输出number类型的x变量 return;&#125; 结构体 (Struct)可以理解成可以存放不同数据类型的数组,一个结构中包含了多个成员的数据类型 ⇩长代码警告! 结构类型结构类型需要使用struct语句,定义变量时需要带上struct以及结构类型名称 格式123456// 声明结构struct 结构体类型名称 &#123; 成员变量;&#125;;// 定义变量struct 结构体类型名称 变量名; 也可以写成下面这样,它们的意思是一样的 1234// 声明结构并定义变量struct 结构体类型名称 &#123; 成员变量;&#125;变量名; 每个变量名都包含结构变量的所有内容,当你要对变量赋值时,需要对应结构体中的成员变量类型 结构运算与数组一样,当需要访问结构成员时,使用变量名 .成员变量的方式 要访问整个结构的时候直接用结构变量的名称就行 对于整个结构,可以做赋值,取地址的操作,还可以传递给函数参数 初始化在定义变量的时候就初始化结构内容 12345678910111213141516#include &lt;stdio.h&gt;// 声明结构并定义变量struct number &#123; int one; int two; int three;&#125; demo;int main() &#123; // 初始化变量struct number类型的变量demo的值为one = 10,two = 20,three = 30 struct number demo = &#123;10, 20, 30&#125;; printf(\"one = %i,two = %i, three = %i\", demo.one, demo.two, demo.three); // one = 10,two = 20, three = 30 return 0;&#125; 还可以用另一种方式去初始化 12345678910111213141516#include &lt;stdio.h&gt;// 声明结构并定义变量struct number &#123; int one; int two; int three;&#125;demo;int main() &#123; // 初始化变量struct number类型的变量demo的值为one = 10,two = 20,three = 30 demo = (struct number)&#123;10, 20, 30&#125;; printf(\"one = %i,two = %i, three = %i\", demo.one, demo.two, demo.three); // one = 10,two = 20, three = 30 return 0;&#125; 甚至你还可以像数组一样对单个成员变量初始化 123456789101112131415#include &lt;stdio.h&gt;// 声明结构并定义变量struct number &#123; int one; int two; int three;&#125;demo;int main() &#123; // 初始化变量struct number类型的变量demo的值为one = 10,three = 30,而没有给值的two默认为0 demo = (struct number)&#123;.one = 10, .three = 30&#125;; printf(\"one = %i,two = %i, three = %i\" , demo.one, demo.two, demo.three); // one = 10,two = 0, three = 30 return 0;&#125; 结构指针与数组不同的是,结构变量的名称并不是结构变量的地址,所以在访问结构变量在内存中的的地址时,需要用到取地址符&amp; 12struct number *p = &amp;demo;printf(\"demo = %p\", p); // demo = 0x10c62b010 需要用指针指向结构内容时,可以用到一个新的运算符-&gt; 意为将指针指向结构的成员 123456789101112131415161718#include &lt;stdio.h&gt;// 声明结构并定义变量struct number &#123; int two;&#125;demo;int main() &#123; // 初始化变量struct number类型的变量demo的值为two = 20 demo = (struct number)&#123; 20 &#125;; printf(\"two = %i\\n\", demo.two); // two = 20 struct number *p = &amp;demo; // 让指针p指向结构变量demo的地址 // 使用指针p去修改结构成员的值 p -&gt; two = 200; // == demo.two = 200; == (*p).two = 200 ; printf(\"two = %i\", p-&gt;two); return 0;&#125; 学生表 12345678910111213141516#include &lt;stdio.h&gt;struct student &#123; int studentID; char *name; char *sex; int age;&#125;first;int main() &#123; //struct student first; first = (struct student) &#123;1003,\"张三\",\"男\",19&#125;; printf(\"名字\\t性别\\t年龄\\t学号\\t\\n%s\\t%s\\t%i\\t%i\" ,first.name, first.sex, first.age, first.studentID); return 0;&#125; 结构函数整个结构可以作为参数的值传入函数 当传递的是一个结构时,在函数中是新建了一个结构变量,并复制了调用者的结构的值 这个函数的返回类型可以是一个结构 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/* * 判断是否为闰年，如果是闰年让今年的2月变成29天 * 明天的日期根据用户输入的值去改变*/#include &lt;stdio.h&gt;#include &lt;stdbool.h&gt;struct date &#123; int month; int day; int year;&#125;;int numberofDays(struct date d);bool isLeap(struct date d);int main() &#123; struct date today, tomorrow; printf(\"Enter today's date (mm-dd-yy):\"); scanf(\"%i-%i-%i\", &amp;today.month, &amp;today.day, &amp;today.year); // 当今天的日期不等于num函数返回的结果时 if (today.day != numberofDays(today)) &#123; // num函数调用主函数中的结构变量today // 明天的日期就+1，月和年保持不变 tomorrow.day = today.day + 1; tomorrow.month = today.month; tomorrow.year = today.year; &#125; else if (today.month == 12) &#123; // 当今年的月份是十二月并且不满足上个if时 // 明天的日期变成1，月份变成1，年份加一 tomorrow.day = 1; tomorrow.month = 1; tomorrow.year = today.year + 1; &#125; else &#123; // 综上条件都不满足，即在月末的最后一天 // 明天的日期变成1，月份加一，年份不变 tomorrow.day = 1; tomorrow.month = today.month + 1; tomorrow.year = today.year; &#125; printf(\"Tomorrow'date is %i-%i-%i\", tomorrow.month, tomorrow.day, tomorrow.year); return 0;&#125;/* * NumberOfDays函数的目的是算出月末的最后一天*/int numberofDays(struct date d) &#123; int days; const int dayspermonth[12] = &#123; 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 &#125;; if (d.month == 2 &amp;&amp; isLeap(d)) &#123; // 如果这个月是2月份，并且isLeap函数返回的是true days = 29; // 就让days变成29 &#125; else &#123; days = dayspermonth[d.month - 1]; // 如果不是2月份就让days变成数组中与月份对应的日子 &#125; return days;&#125;/* * isLeap函数的作用是判断是否是闰年 * 返回值默认是false，如果是闰年就返回true*/bool isLeap(struct date d) &#123; bool leap = false; if ((d.year % 4 == 0 &amp;&amp; d.year % 100 != 0) || d.year % 400 == 0) &#123; leap = true; &#125; return leap;&#125; 结构数组声明结构数组:struct 结构体类型名称 成员变量[数组元素个数]例如 123456789101112131415161718192021#include &lt;stdio.h&gt;struct time &#123; int hour; int min; int seconds;&#125;NowTime;int main() &#123; struct time NowTime[5] = &#123; // NowTime[0] = ((NowTime.hour = 11),(NowTime.min = 59),(NowTime.seconds = 59)) &#123;11,59,59&#125;, // NowTime[1] = ((NowTime.hour = 12),(NowTime.min = 0),(NowTime.seconds = 0)) &#123;12,0,0&#125;, // ...以此类推 &#123;1,59,29&#125;, &#123;23,59,59&#125;, &#123;19,50,29&#125; &#125;; return 0;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/* * 定义一个结构数组，分别存放小时分钟秒 * 遍历数组，输出每一个数组元素 * 定义第二个函数，作用是算出当前时间的下一秒的时间*/#include &lt;stdio.h&gt;// 声明结构struct time &#123; int hour; int min; int seconds;&#125; NowTime;// 声明函数struct time LaterTime(struct time now);int main() &#123; // 常量CURT的值是5 const int CURT = 5; // 初始化结构数组 struct time NowTime[CURT] = &#123; // NowTime[0] = ((NowTime.hour = 11),(NowTime.min = 59),(NowTime.seconds = 59)) &#123;11, 59, 59&#125;, &#123;12, 0, 0&#125;, &#123;1, 59, 29&#125;, &#123;23, 59, 59&#125;, &#123;19, 50, 29&#125; &#125;; struct time *p = NowTime; // 定义struct time类型的指针变量p for (int i = 0; i &lt; CURT; i++) &#123; *p = NowTime[i]; // 让指针变量p指向结构数组NowTime，每轮循环让NowTime[0+i] printf(\"Nowtime is %.2i:%.2i:%.2i\", p-&gt;hour, p-&gt;min, p-&gt;seconds); // 指针变量p指向每个结构成员 *p = LaterTime(*p); // 让指针变量p指向函数LaterTime，参数是NowTime[0+i] printf(\"...One seconds later its %.2i:%.2i:%.2i\\n\", p-&gt;hour, p-&gt;min, p-&gt;seconds); &#125; return 0;&#125;struct time LaterTime(struct time now) &#123; ++now.seconds; if (now.seconds == 60) &#123; now.seconds = 0; ++now.min; if (now.min == 60) &#123; now.min = 0; ++now.hour; if (now.hour == 24) &#123; now.hour = 0; &#125; &#125; &#125; return now;&#125; 嵌套结构(禁止套娃!)既然结构内可以是不同类型的数据,那么也可以是结构类型的数据 1234struct aAndb&#123; struct a dataa; struct b datab;&#125;; 空间想象力太差了,告辞 复用的时候看作文件夹与快捷键就行 123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;struct point &#123; int x; int y;&#125;;struct rectangle &#123; struct point p1; struct point p2;&#125;;void printRect(struct rectangle r) &#123; printf(\"&lt;%d,%d&gt; to &lt;%d,%d&gt;\\n\", r.p1.x, r.p1.y, r.p2.x, r.p2.y);&#125;int main() &#123; struct rectangle rects[] = &#123; /* * rects[0] r.p1.x = 1,r.p1.y = 2 * rects[0] r.p2.x = 3,r.p2.y = 4 * rects[1] r.p1.x = 5,r.p1.y = 6 * rects[1] r.p2.x = 7,r.p2.y = 8 */ &#123;&#123;1, 2&#125;, &#123;3, 4&#125;&#125;, &#123;&#123;5, 6&#125;, &#123;7, 8&#125;&#125; &#125;; for (int i = 0; i &lt; 2; i++) &#123; printRect(rects[i]); &#125; return 0;&#125; TypeDef使用typedef可以自定义数据类型的名称,让其变成新的别名 复杂的名字化繁为简,重载已有的类型名称,新名称的含义更清晰更具有移植性 还能够替代数据类型出现在变量定于和参数声明 使用typedef最后的单词就是该类型的新名称 123typedef int abc; // 将int类型定义别名为abcabc a,b,c; // 等价于int a,b,cabc number[5]; // 等价于int number[5] 1234567typedef struct student &#123; int studentID; char *name; char *sex; int age;&#125;aaa; aaa zhangsan = &#123;111,\"zhangsan\",\"nan\",17&#125;; union(联合)联合是一种特殊的数据类型,允许在相同的内存位置存储不同的数据类型 可以定义一个带有多成员的联合体,但是任何时候只能有一个成员带有值,联合体提供了一种使用相同的内存位置的有效方式 它的语法和结构一样,但是每个成员是共享一个空间 而且同一时间只有一个成员是有效的,union整体的空间大小就是最大的那个成员 所以你不能同时输出联合体中的所有成员的值 1234567891011121314151617181920212223#include &lt;stdio.h&gt;#include &lt;string.h&gt;union Data &#123; int i; float f; char str[20];&#125;;int main() &#123; union Data data; data.i = 10; printf(\"data.i : %d\\n\", data.i); data.f = 220.5; printf(\"data.f : %f\\n\", data.f); strcpy(data.str, \"Hello,World\"); printf(\"data.str : %s\\n\", data.str); return 0;&#125;","categories":[],"tags":[{"name":"C","slug":"C","permalink":"https://zhboat.ink/tags/C/"}]},{"title":"C语言笔记(9)","slug":"C语言笔记-9","date":"2020-06-07T07:54:20.000Z","updated":"2020-11-14T05:12:32.205Z","comments":true,"path":"C语言笔记-9/","link":"","permalink":"https://zhboat.ink/C%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0-9/","excerpt":"字符串","text":"字符串 字符串是以字符数组的方式存在的 不能对其用运算符做运算 通过数组的方式可以遍历字符串 可以通过字符串常量去初始化字符数组 字符数组 以0结尾的一串字符 0标志字符串的结束,但它不是字符串的一部分,计算字符串长度的时候不包含这个0 字符串以数组的形式存在,以数组或指针的形式访问 格式: char hello[] = {&#39;H&#39;,&#39;e&#39;,&#39;l&#39;,&#39;l&#39;,&#39;o&#39;,&#39;!&#39;,&#39;\\0&#39;}; 每个字符使用单引号 结尾的&#39;\\0&#39;可以写成0,但是不能写成’0’ 对应的分别是 元素 值 hello[0] H hello[1] e hello[2] l hello[3] l hello[4] o hello[5] ! hello[6] \\0 字符串变量指针变量 char *string = &quot;Hello&quot;; 字符数组 char word[] = &quot;Hello&quot;; 字符数组char line[6] = &quot;Hello&quot;会占据6个字节的空间 字符数组在本地存放,本地变量的空间会自动回收 指针用来处理参数和不可修改的值,以及动态分配空间 当需要构建一个字符串时使用数组的方式,当处理字符串时用指针 char *字符串可以表达成char*的形式,但char* 不一定是字符串,只有当它所指的字符数组的结尾处是0才能确定它指向的是字符串 字符串常量“Hello”就是字面量/常量,它会被编译器变成一个字符数组放在某处,这个数组的长度是字符+1,在结尾处还有个表示结束的0 两个相邻的字符串常量会被自动连接起来 当使用指针去定义字符串的时候,字符串常量是只读的,无法被修改 const char *s = &quot;Hello,World&quot;; 当有第二个指针变量指向了已有的常量时,它们的地址是一模一样的 123456789#include &lt;stdio.h&gt;int main() &#123; char *s = \"Hello,Wolrd\"; char *s2 = \"Hello,Wolrd\"; printf(\"s = %p\\n\", s); // s = 0x10e9c2f92 printf(\"s2 = %p\", s2); // s2 = 0x10e9c2f92 return 0;&#125; 如果需要修改字符串中的常量,需要使用字符数组去定义字符串char word = &quot;Hello,Wolrd&quot;; 输入输出将指针变量a字符串赋值给另一个指针b的时候,是将a地址指向了b,将它们两个链接起来了,对b做的任何操作都会映射到a 1234567891011#include &lt;stdio.h&gt;int main() &#123; char *a = \"Hello,Wolrd\"; char *b = a; printf(\"a = %s\\n\", a); // a = Hello,World printf(\"a = %p\\n\", a); // a = 0x104f2af82 printf(\"b = %p\\n\", b); // b = 0x104f2af82 printf(\"b = %s\", b); // b = Hello,World return 0;&#125; scanf作为字符串输入时,会读入一个单词(一串字符以空格和tab作为结束) 限制scanf的长度为12scanf (&quot;%12s, a&quot;);当超过12个字符后,越界的部分会被裁掉,当有连续的字符串时,会被挤到下个scanf 定义指针类型的字符串时,需要对变量进行初始化为0 空字符串char a[10] = &quot;&quot;意味着这是一个空的字符串,a[0] == ‘\\0’ char a[] = &quot;&quot;意味着这个字符串的长度只有1,而a[0]就是’\\0’,所以你放不下任何东西 程序参数main函数的参数有两个参数,前者a是告诉后者b数组中有多少个元素 后者b是在执行时可以带上的任何字符 123456789#include &lt;stdio.h&gt;int main(int a, char *b[]) &#123; int i; for ( i = 0; i &lt; a; i++ ) &#123; printf(\"%d:%s\\n\", i, b[i]); &#125; return 0;&#125; 输入输出putcharint putchar(int x) 把一个字符输出在标准输出上 当输出EOF( -1 )代表输出失败 参数是int类型,但只能接收一个字符,返回类型也是in getchar不需要参数int getchar(void) 返回从标准输入读取到的字符 返回类型是int,目的是为了返回EOF( -1 )表示标准输入结束 当程序获取到EOF状态,即当用户使用Ctrl + D中断运行,就会在标准输出得到EOF结束程序运行 字符串函数 在头文件string.h中有很多函数可以调用 strlen (string length)返回字符串的长度(不包含结尾的\\0)size_t strlen(const char *s); 不会修改参数表中的参数 123456789#include &lt;stdio.h&gt;#include \"string.h\"int main() &#123; char s[] = \"Hello\"; printf(\"sizeof = %lu\\n\", sizeof(s)); // sizeof = 6 printf(\"strlen = %lu\\n\", strlen(s)); // strlen = 5 return 0;&#125; 仿照strlen函数写一个自己的函数 12345678910111213141516#include &lt;stdio.h&gt;#include \"string.h\"int my( const char *s ) &#123; int time = 0; while ( s[time] != '\\0' ) &#123; time++; &#125; return time;&#125;int main() &#123; char s[] = \"Hello\"; printf(\"sizeof = %lu\\n\", sizeof(s)); // sizeof = 6 printf(\"strlen = %lu\\n\", my(s)); // strlen = 5 return 0;&#125; strcmp (string compare)对比两个字符串的大小,同样不会修改字符串int strcmp(const char *s1,const char *s2) 前者比较后者,前者与后者相同则返回0,前者小于后者则结果小于0,前者大于后者则结果大于0 不相等的结果取决于等于两者之间的差值,按照ASCII表中字符的顺序计算 123456789#include &lt;stdio.h&gt;#include \"string.h\"int main() &#123; char s1[] = \"abc\"; char s2[] = \"abc\"; printf(\"%d\", strcmp(s1,s2)); // 0 return 0;&#125; 仿照strcmp函数写一个自己的函数 12345678910111213141516#include &lt;stdio.h&gt;#include \"string.h\"int my(const char *s1,const char *s2)&#123; while ( *s1 == *s2 &amp;&amp; *s1 != '\\0' )&#123; s1++; s2++; &#125; return *s1 - *s2;&#125;int main() &#123; char s1[] = \"abc\"; char s2[] = \"abc\"; printf(\"%d\", my(s1,s2)); // 0 return 0;&#125; strcpy (string copy)char *strcpy(char *restrict s1,const char *restrict s2)将后者的内容拷贝到前者 restrict表示这两个字符串在地址中没有重叠部分 strcpy具有返回值,能够继续参与代码的其他运算,返回值是前者 123456789#include &lt;stdio.h&gt;#include \"string.h\"int main() &#123; char s1[] = \"123\"; char s2[] = \"abc\"; printf(\"s1 = %s\", strcpy(s1, s2)); // abc return 0;&#125; strcat (concatenate string)char *strcat(char *restrict s1,const char *restrict s2)把后者连接到前者的后面,拼凑成一个字符串 restrict表示这两个字符串在地址中没有重叠部分 返回值是s1,在完成拼凑的这个操作时,得确保s1的空间是足够容纳s2的内容 123456789#include &lt;stdio.h&gt;#include \"string.h\"int main() &#123; char s1[12] = \"Hello,\"; char s2[12] = \"World\"; printf(\"s1 = %s\", strcat(s1,s2)); // Hello,World return 0;&#125; strchr (locate character in string)char *strchr(const char *s, int c);返回一个指针,指向变量c第一次出现的位置,自左向右寻找 char *strrchr(const char *s, int c);返回一个指针,指向变量c第一次出现的位置,自右向左寻找 当返回Null时表示没有找到,非0的值表示寻找到了,并返回指针 123456789#include &lt;stdio.h&gt;#include \"string.h\"int main() &#123; char s[] = \"11223344\"; char *p = strchr(s, '2'); // 223344 printf(\"%s\", p); return 0;&#125; 定位第二个相同字符12345678910#include &lt;stdio.h&gt;#include \"string.h\"int main() &#123; char s[] = \"11223344\"; char *p = strchr(s, '2'); // 223344 p = strchr(p + 1, '2'); // 23344 printf(\"%s\", p); return 0;&#125; 反向定位第一个2开始算作p[0]以此类推 首先将p[0]的值备份一下,然后让它变成\\0代表结束 动态分配一个临时的变量t去保存字符串s的值,也就是11 t = | 1 | 1 | \\0 | 2 | 3 | 3 | 4 | 4 | \\0 | 再恢复*p的值 s = | 1 | 1 | 2 | 2 | 3 | 3 | 4 | 4 | \\0 | 123456789101112131415#include &lt;stdio.h&gt;#include \"string.h\"#include \"stdlib.h\"int main() &#123; char s[] = \"11223344\"; char *p = strchr(s, '2'); // 223344 char c = *p; // char c = p[0] = 2; 备份*p *p = '\\0'; // p[0] = '\\0' char *t = (char*)malloc(strlen((s)+1)); strcpy(t, s); // 将s的值拷贝到t中 *p = c; // 恢复*p printf(\"%s\", t); free(t); // 释放临时变量t的空间 return 0;&#125; strstr (locate a substring in a string)char *strstr(const char *s1, const char *s2);从字符串s2中定位s1的内容,并返回一个指针 12345678910#include &lt;stdio.h&gt;#include \"string.h\"int main() &#123; char s1[10] = \"11223344\"; char s2[10] = \"22\"; char *p = strstr(s1,s2); printf(\"%s\", p); // 223344 return 0;&#125; char *strcasestr(const char *s1, const char *s2);从字符串s2中定位s1的内容忽略大小写,并返回一个指针 12345678910#include &lt;stdio.h&gt;#include \"string.h\"int main() &#123; char s1[10] = \"aabbcdDee\"; char s2[10] = \"Dd\"; char *p = strcasestr(s1,s2); printf(\"%s\", p); // dDee return 0;&#125; char *strnstr(const char *s1, const char *s2, size_t 3);仅从3个长度的字符串s2中定位s1的内容,并返回一个指针,当超过3个长度会返回null 12345678910#include &lt;stdio.h&gt;#include \"string.h\"int main() &#123; char s1[10] = \"123456789\"; char s2[10] = \"5\"; char *p = strnstr(s1,s2,7); // 长度可以为7 printf(\"%s\", p); // 56789 return 0;&#125; 限制字符串数量strncpy限制拷贝的最大字符数为12 char *strncpy(char *restrict s1,const char *restrict s2,size_t n); – &gt; strncpy(s1,s2,12); strncat限制能将后者连接到前者的最大字符数为12 char *strncat(char *restrict s1,const char *restrict s2,size_t n); –&gt; strncat (s1,s2,12); strncmp限制仅对比开头的三个字符 int strncmp(const char *s1,const char *s2,size_t n); –&gt; strncmp(s1,s2,3)","categories":[],"tags":[{"name":"C","slug":"C","permalink":"https://zhboat.ink/tags/C/"}]},{"title":"C语言笔记(8)","slug":"C语言笔记-8","date":"2020-06-02T07:25:20.000Z","updated":"2020-11-14T05:12:32.205Z","comments":true,"path":"C语言笔记-8/","link":"","permalink":"https://zhboat.ink/C%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0-8/","excerpt":"指针","text":"指针 取地址内存分配的任务是通过指针去执行的,每一个变量在内存中都会有一个位置,可以通过&amp; 运算符去访问变量在内存中的地址 地址的大小是否与int相同取决于编译器 运算符&amp;获得变量的地址,它的操作数必须是变量 scanf(&quot;%d&quot;, &amp;x); &amp;只能对一个明确的变量去取地址,不能对没有地址的东西取地址(包括表达式和运算) 输出格式%p 可以输出变量的地址 printf(&quot;%p&quot;, &amp;x); 输出x变量在内存中的地址 相邻变量的地址本地变量在内存存放在堆栈里,堆栈是自顶向下分配的,先定义的变量在后定义变量的上方,紧紧相连,但地址间隔着一个int大小的字节 123456789#include &lt;stdio.h&gt;int main() &#123; int i = 1; int j; printf(\"%p\\n\", &amp;i); // 0x7ffee5e29b58 printf(\"%p\", &amp;j); // 0x7ffee5e29b54 return 0;&#125; 数组的地址整个数组的地址与数组中第一个元素即x[0]相同 相邻的数组元素的地址相隔一个int的字节 123456789#include &lt;stdio.h&gt;int main() &#123; int x[5]; printf(\"%p\\n\", &amp;x); // 0x7ffee5dd7b40 printf(\"%p\\n\", &amp;x[0]); // 0x7ffee5dd7b40 printf(\"%p\\n\", &amp;x[1]); // 0x7ffee5dd7b44&#125; 指针保存地址的变量 指针是一个变量,其值为另一个变量的地址,即内存位置的直接地址 就像其他变量或常量一样,必须在使用指针存储其他变量地址之前,对其进行声明 格式数据类型 *变量名 = &amp;变量名 int *p = &amp;x;变量p的值存储着变量x在内存中的地址 12345678910#include &lt;stdio.h&gt;int main() &#123; int x = 2; int *p = &amp;x; printf(\"%p\\n\", &amp;x); // 0x7ffee2330b58 printf(\"%p\\n\", p); // 0x7ffee2330b58 return 0;&#125; 而int *p,i;是定义了一个指针类型p和int类型i,并非两个都是指针,需要二者都是指针时需要在第二个变量前也加上* 指针变量指针变量的值就是普通变量在内存的地址,而普通变量的值是实际意义上的值 指针作为参数int i = 0;x(&amp;i); 把变量i在内存中的地址通过传参的方式传递给函数x void x(int *p)在被调用的时候得到了变量i的地址 1234567891011#include &lt;stdio.h&gt;void x(int *p);int main() &#123; int i = 1; printf(\"&amp;i = %p\\n\", &amp;i); // 0x7ffee3744b58 x(&amp;i); return 0;&#125;void x(int *p) &#123; printf(\"p = %p\\n\", p); // 0x7ffee3744b58&#125; 通过指针访问变量*是一个弹幕运算符,可以用来访问指针的值(变量的地址)所表示的变量的值 指针类型的变量可以作为左值也可以作为右值,与上一篇笔记中谈到的数组一样,当它在左边时是作为写入的方式,在右边时是被读取 左值与右值并非变量而是特殊的值,是表达式计算的结果 int i = *p 把指针p所指向的变量的值赋值给i *p = i + 1; i + 1的值赋值给指针p所指向的变量的值 有点绕,但是不难理解~ 12345678910111213#include &lt;stdio.h&gt;void x(int *p);int main() &#123; int i = 1; printf(\"&amp;i = %p\\n\", &amp;i); // 0x7ffee3744b58 printf(\"i = %d\\n\", i); // 1 x(&amp;i); return 0;&#125;void x(int *p) &#123; printf(\"p = %p\\n\", p); // 0x7ffee3744b58 printf(\"*p = %d\\n\", *p); // 1&#125; ⇩因为传递给x的是i在内存中的地址,所以当我们修改*p也就是修改变量i在内存中地址上实际的值即 *p= i = 2 123456789101112131415#include &lt;stdio.h&gt;void x(int *p);int main() &#123; int i = 1; printf(\"&amp;i = %p\\n\", &amp;i); // 0x7ffee3744b58 printf(\"i = %d\\n\", i); // 1 x(&amp;i); printf(\"i = %d\\n\", i); // 2 return 0;&#125;void x(int *p) &#123; printf(\"p = %p\\n\", p); // 0x7ffee3744b58 printf(\"*p = %d\\n\", *p); // 1 *p = 2; // 将2的值赋值给了实际变量i&#125; &amp;*互相反作用 *&amp; new = *&amp;i = new = *(&amp;i) = new = *(0x7ffee3744b58) = new = i 1234567891011#include &lt;stdio.h&gt;int main() &#123; int i = 1; printf(\"&amp;i = %p\\n\", &amp;i); // 0x7ffee3744b58 printf(\"i = %d\\n\", i); // 1 int *p = &amp;i; printf(\"*p = %p\\n\", p); // 0x7ffee3744b58 int new = *&amp;i; printf(\"new = %d\", new); // 1 return 0;&#125; &amp;*同理 注意事项别在定义指针后还没指向任何变量就开始使用指针 一定要按照规范写法去定义指针变量int *p = &amp;x; 数组与指针 数组变量是特殊的指针,数组变量本身表达的就是在内存中的地址 int a[10]; int *p =a; 无需使用&amp;取地址 但是数组中的元素表达的是单个的变量,这时就需要使用&amp;去取地址 a == &amp;a[0] a的地址和a[0]的地址是一样的概念 甚至[]运算符不仅可以对数组用,还可以对指针使用 int x = 2;int *p = &amp; x;p[0] == x[0]可以将普通变量x看作是只有一个元素的数组,所以p[0] = 2 除了可以读取值以外还能往数组里写入值 123456789101112#include &lt;stdio.h&gt;int main() &#123; int x = 2; int *p = &amp;x; printf(\"x = %d\\n\", x); // x = 2 printf(\"p[0] = %d\\n\", p[0]); // p[0] = 2 p[0] = 4; printf(\"x = %d\", x); // 被修改后x = 4 return 0;&#125; 函数_数组传值 函数参数表中的数组实际上是指针,即sizeof[a] == sizeof (int *) 在函数中声明的时候可以用*数组名称的方式,还可以继续用数组的运算符[]进行计算 数组参数的等价关系在参数表和函数原型中它们的表达意思都是一样的 int sum(int *a,int n); == int sum(int *,int); == int sum(int a[],int n); == int sum(int [],int); 指针与constconst指针 *在const的左边表示指针是const 当const指针指向了某个变量的地址之后,就无法再指向其他变量了,即无法修改变量的地址(指针的值)了 p = &amp;y无法通过编译,因为变量p是const类型的,不能被分配任何值 123456789101112#include &lt;stdio.h&gt;int main() &#123; int x = 2; int y = 3; int * const p = &amp;x; printf(\"x = %d\\n\" ,*p); // 2 *p = 30; printf(\"x = %d\" ,*p); // 30 p = &amp;y; // Cannot assign to variable 'p' with const-qualified type 'int *const' return 0;&#125; *在const右边表示指针变量是const const指针变量指向了某个变量的地址之后,就不能通过这个指针去修改那个变量了,并非真正意义上让普通变量变成了const *p = 30无法通过编译,因为指针变量*p是一个只读的变量 其他修改指针的操作可以正常编译 12345678910111213#include &lt;stdio.h&gt;int main() &#123; int x = 2; int y = 3; int const *p = &amp;x; printf(\"x(%%p) = %p\\n\", p); // 0x7ffeebb2ab58 printf(\"x(%%d) = %d\\n\", *p); // 2 *p = 30; // Read-only variable is not assignable p = &amp;y; printf(\"y(%%p) = %p\", p); // 0x7ffeebb2ab54 return 0;&#125; 转换const你可以将一个普通变量转换成const类型,让其在函数中无法被修改 const数组因为数组已经是一个特殊的const类型的指针了,所以在数组前加上const能让数组中的每个元素都变成const类型的变量 const int x[] = {1,2,3,4,5,6,7,8,9,10,}; 当用这种方式创建数组时,就需要在初始化时就对数组进行赋值,因为你无法再修改数组中的元素了 因为把数组传入给函数时传递的是地址,所以在函数中可以修改数组的值,所以传值给函数的时候也可以让函数声明数组是const,这样就能保护数组在函数中不会被修改 int a(const int x[]); 指针运算指针是用十六进制的地址表示普通变量的值,如果对指针执行算数运算可以让地址指向的数组元素向前或向后移动 如果指针不是指向一片如数组一样连续分配的空间,那么这种运算没有意义可言 加减、递增递减让指针加1的操作并非让地址真的+1了,加的是sizeof的值,也就是指针所指的普通变量的数据类型的大小 char类型的指针+1,它的地址加上的是char类型的大小 12345678910#include &lt;stdio.h&gt;int main() &#123; char a[] = &#123;0,1,2,3,4,5,6,7,8,9,&#125;; char *p = a; printf(\"char = %d\\n\", sizeof(char)); // 1 printf(\"p = %p\\n\", p); // 0x7ffee5bbeabe +1⇩ printf(\"p+1 = %p\\n\", p + 1); // 0x7ffee76f5abf return 0;&#125; 同理,当类型是int的时候,地址+1的操作就是加上一个int类型的大小 12345678910#include &lt;stdio.h&gt;int main() &#123; int a1[] = &#123;0,1,2,3,4,5,6,7,8,9,&#125;; int *p = a1; printf(\"int = %d\\n\", sizeof(int)); // 4 printf(\"p = %p\\n\", p); // 0x7ffee7ac6aa0 +1⇩ printf(\"p+1 = %p\\n\", p + 1); // 0x7ffee7ac6aa4 return 0;&#125; *p + 1没有意义,*(p + 1)才是指向数组的下一个元素 因为*(p + 1) = a[1],*(p + n) = a[n] 那么既然加法可以看作是向后移动,减法就是向前移动了 递增递减相应的也是向前向后挪一个元素的动作 当两个指针相减的时候,减出来的差并非是地址的差,而是地址的差/数据类型大小的差 123456789101112#include &lt;stdio.h&gt;int main() &#123; int a1[] = &#123;0,1,2,3,4,5,6,7,8,9,&#125;; int *p = a1; int *p1 = &amp;a1[5]; printf(\"int = %d\\n\", sizeof(int)); // 4 printf(\"p = %p\\n\", p); // 0x7ffee7ac6aa0 printf(\"p1 = %p\\n\", p1); // 0x7ffee9f67ab4 printf(\"p1-p = %d\", p1 - p); // 5 return 0;&#125; 0xb4 = 180 - 0xa0 = 160 = 0x14 = 20 20 / 4(sizeof(int))= 5; *p++++的优先级比*来的高,所以先算p++的结果 作用于数组类的连续空间操作 使得遍历数组元素时有更高效率的办法 123456789101112#include &lt;stdio.h&gt;int main() &#123; int a[] = &#123;0,1,2,3,4,5,6,7,8,9,&#125;; int *p = a,t = *p; int size = sizeof(a) / sizeof(a[0]); while ( *p &lt; size &amp;&amp; *p &gt;= t ) &#123; printf(\"p = %d\\n\", *p); *p++; &#125; return 0;&#125; 比较&lt;,&lt;=,==,&gt;,&gt;=,!=都可以使用,用来比较普通变量在内存中的地址的大小 因为数组的元素的地址是线性递增的,所以a[5] &gt; a[4] 0地址指针的地址不应该被写入0地址 但可以用0地址表示特殊的事情 返回的指针是无效的 指针没有被真正初始化(先初始化为0) NULL在事先定义在C语言中,它表示0地址 类型为了避免错用指针,不同类型的指针是不能直接互相赋值的 无论指向什么类型,所有的指针大小都是不一样的 void转换类型 void* 表示指向了未知类型的指针 int \u0001*p = &amp;i; void *q = (void*)p; 并没有改变p所指i变量的类型,而是从q去访问i的时候不再将i当做是int类型 动态内存分配malloc格式:数据类型 *变量名 = (数据类型*)malloc(x*sizeof(数据类型)) int *p = (int *)malloc(n * sizeof(int); 在使用malloc函数之前需要在头文件中添加stdlib.h malloc 需要的是参数不是数组里有多少个元素,而是有多少个字节,用数组总共的元素数量去乘以int类型的字节数就能得到malloc需要的参数了 malloc返回的结果是void*所以还需要用强制转换成int类型的值才能当作元素个数使用 由于数组是特殊的指针,所以这里定义的指针可以拿来当数组去使用 free一个malloc对应一个free,程序中出现malloc就带上free 释放内存,只能释放malloc使用的原始地址,即使被修改过也不行 free过的地址不能再次free 指针应用场景 交换两个变量的值 123456789101112131415#include &lt;stdio.h&gt;void swap(int *a,int *b);int main() &#123; int a , b; a = 5; b = 6; swap(&amp;a,&amp;b); printf(\"a = %d,b = %d\\n\", a, b); return 0;&#125;void swap(int *a,int *b)&#123; int tmp = *a; *a = *b; *b = tmp;&#125; 返回多个值 找出数组中最小和最大的值 123456789101112131415161718192021#include &lt;stdio.h&gt;void minmax(int a[], int size, int *min, int *max);int main() &#123; int a[] = &#123;1,2,3,4,5,6,7,8,9,12,14,17,22,25,39,44,55,99&#125;; int min,max; int size = sizeof(a)/ sizeof(a[0]); minmax(a,size,&amp;min,&amp;max); // 传递a数组,a数组的元素数量,min和max变量的地址 printf(\"min = %d,max = %d\", min, max); return 0;&#125;void minmax(int a[], int size, int *min, int *max)&#123; int i; *min = *max = a[0]; // 初始化min和max变量的值为a数组第一个值 for ( i = 1; i &lt; size; i++ ) &#123; // 历遍数组 if ( a[i] &lt; *min )&#123; *min = a[i]; &#125; else if ( a[i] &gt; *max )&#123; *max = a[i]; &#125; &#125;&#125; 函数返回异常值 函数返回运算的状态,而结果通过指针去返回 当任何数值都是有效的可能结果时,得分开返回 12345678910111213141516171819#include &lt;stdio.h&gt;int main() &#123; int a = 5, b = 2; int c; if (divide( a, b, &amp;c ))&#123; // 将a，b的值，c的地址传递给divide函数 printf(\"%d/%d=%d\", a, b, c); &#125; return 0;&#125;int divide( int a, int b, int *res )&#123; int ret = 1; if ( b == 0)&#123; ret = -1; // 如果分母是0的话返回错误值-1 &#125; else&#123; *res = a / b; // 否则的话返回值是a除以b的值 &#125; return ret;&#125; 啊这…写得也太多了吧","categories":[],"tags":[{"name":"C","slug":"C","permalink":"https://zhboat.ink/tags/C/"}]},{"title":"C语言笔记(7)","slug":"C语言笔记-7","date":"2020-05-28T09:40:20.000Z","updated":"2020-11-14T05:12:32.205Z","comments":true,"path":"C语言笔记-7/","link":"","permalink":"https://zhboat.ink/C%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0-7/","excerpt":"数组","text":"数组 数组可以存储一个固定大小的相同类型元素的顺序集合 数组的目的是存储一系列数据,但它往往被认为是一系列相同的变量 数组一旦被创建了就不能再改变它的大小了,元素在内存中是连续依次排列的 格式声明数组 数据类型 变量名称 [元素数量] 元素的数量必须是整数 例如:double number[5] 意味着这是一维数组,声明了一个类型为int包含了5个元素的数组number,它可以容纳5个int类型的数据 初始化数组 可以逐个初始化数组,也可以使用一条初始化语句数据类型 变量名称 [元素数量] = { 1000.0 , 2.0 , 3.4 , 7.0 , 50.0 } 如果元素数量很多个,初始化的值只有一个的情况下,除了第一个元素会是初始化的值以外,其余全是0 指定元素初始化数据类型 变量名称 [元素数量] = { [0] = 1000.0 , [2] = 3.4 , 7.0 , [4] = 50.0 },当指定了索引的时候,初始化会根据索引来定位,没有指定索引的数据接在前面一个数据的后面,其他没有初始化的值仍然是0 如果没有声明元素数量的话,则按照初始时元素的个数来定义 创建一个数组,它与声明数组时的变量名称是相同的变量名称 [索引] = 值 索引从0开始计数 从元素0开始,数组后面的每个索引都是数组的个数减1 索引有效的范围是从[0 ~ 数组大小-1],一旦越界可能会出现程序崩溃等问题 number[4] = 50.0 意味着number数组里的第五个元素的值是50.0 除了可以直接写索引数值外还可以写上变量,但是如果你需要依次向后填入数值的话,这个变量需要变化 赋值数组元素 数组元素可以通过数组名称 [索引]进行访问,所以也能将索引对应的元素赋值给其他变量 可以出现在复制的左边或者右边,把数组放在右边就是读取它的值,放在左边就是将右边的数值写入数组 number[3] = number[5] + 6 即把数组中的第六个元素的值加上六后写入到数组第四个元素中 double num4 = number [3]即把数组中的第四个元素的值赋给了num4变量 遍历数组通常采取for循环的方式,让循环的变量i从0到i&lt;元素数量,这样循环体内最大的i正好是数组最大的有效索引 而不可以将循环结束的条件&lt;=元素数量,也不可以在离开循环之后继续将i的值来作为数组元素的索引 数组的大小sizeof函数能给出整个数组所占据内容的大小,单位是字节 使用sizeof(数组名称)可以得到整个数组的字节sizeof(number)/sizeiof(number[0]) sizeof(number[0])给出了数组中单个元素的大小,于是相除就得到了数组的元素个数 这样的计算方式能够让代码复用,当修改数组中初始的数据时,不需要修改遍历的代码 数组传值 如果想把a数组中的所有元素直接赋值给b数组,只能通过for循环的方式实现 数组变量本身不能被赋值 需要赋值的时候只能采取遍历将一个数组中的所有元素交给另一个数组 123for ( i = 0 ; i &lt; length (number的元素数量) ; i++ )&#123; new[i] = number[i];&#125; 当数组作为函数参数时,往往还必须再用另一个函数来传入数组的大小 不能在[]中给出数组的大小 不能再利用sizeof去计算数组的元素个数 12345int secondary(int size);int main int size = sizeof(number)/ sizeof(number[0]); secondary(size);int secondary(int size) 练习 写出一个程序计算用户输入一个数字的数量,用户可以输入这么多数量的数字,当输入-1的时候结束用户输入,计算这些数字的平均数,并输出所有大于平均数的数 123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;int main() &#123; int x; double sum = 0; int time; printf(\"请输入数字的数量：\"); scanf(\"%d\", &amp;time); if ( time &gt; 0)&#123; int num[time]; // C99的特性,可以根据动态的变量去定义数组数量 scanf(\"%d\", &amp;x); for ( time = 0; x != -1 ; time++) &#123; // time从0开始,每轮time++,直到x = -1结束循环 num[time] = x; sum += x; scanf(\"%d\", &amp;x); // 输入-1结束循环 &#125; if ( time &gt; 0) &#123; double avg = sum / time; // 计算平均数 for (int i = 0; i &lt; time; i++) &#123; if (num[i] &gt; avg) &#123; // num[i] = num[time] = x &gt; avg printf(\"%d\\n\", num[i]); &#125; &#125; &#125; &#125; return 0;&#125; 写出一个程序,输入数量不确定的[0,9]范围内的整数,统计每一种数字出现的次数,当输入-1的时候表示结束 12345678910111213141516171819#include &lt;stdio.h&gt;int main() &#123; const int NUM = 10; // 定义常量NUM的值为 10 int i; int x; scanf(\"%d\", &amp;x); int time[NUM] = &#123;0&#125;; // 有10个int类型的数据,并将它们全都初始化为0 while ( x != -1 )&#123; if ( x &gt; 0 &amp;&amp; x &lt;= NUM - 1 )&#123; time[x]++; // 当x满足0 &lt; x &lt; 9,让time[ x：0 ~ 9 ]++ &#125; scanf(\"%d\", &amp;x); // 输出-1结束 &#125; for ( i = 0; i &lt; NUM ; i++) &#123; // i : 0 ~ 9 printf(\"%d:%d\\n\", i, time[i]); // time[i：0 ~ 9 ]出现过几次就会输出多少次 &#125; return 0;&#125; 当用户输入某个数值时,从一组固定的数据中寻找是否存在,如果存在就输出它和它在数组中的位置,不存在就输出-1 12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;int search( int y, b[], size ); // 声明函数int main() &#123; int a[] = &#123; 1 , 3 , 5 , 7 , 9 , 2 , 4 , 6 , 8 , 10 &#125;; int x; int size = sizeof(a)/ sizeof(a[0]); // 得到元素个数 int loc; printf(\"请输入一个数字:\"); scanf(\"%d\", &amp;x); loc = search( x , a , size ); // 传值给search函数，返回loc = ret; if ( loc != -1 )&#123; printf(\"%d在第%d个位置上\\n\", x, loc); &#125; else&#123; printf(\"%d不存在\\n\", x); &#125; return 0;&#125;int search( int y, b[], size )&#123; int ret = -1; int i; for ( i = 0; i &lt; size; i++) &#123; // 遍历数组 if ( b[i] == y )&#123; // 当数组中的数等于用户输入数时返回ret = i 的值 ret = i; // 否则返回ret = -1 break; &#125; &#125; return ret;&#125; 老朋友:素数 // 数组都没整明白又来让我脑壳痛的素数🙃,先囫囵吞枣消化再说 1234567891011121314151617181920212223242526272829303132333435/* * 构建n以内的素数表 * 0. 定义，并初始化数组prime[n]所有元素为1 * 当prime[x]为1则表示x是素数 * 1. 让x的值为2 * 2. 让2x、3x、4x 直至到n倍数的数标记为非素数 * 3. 如果x是素数，则对于（ i = 2; x * i &lt; n; i++ ）令prime[i * x] = 0 * 4. 令x为下一个没有被标记的非素数的数重复步骤2 * 直到所有的数都已经尝试完成 * */#include &lt;stdio.h&gt;int main() &#123; int i; int n; scanf(\"%d\", &amp;n); int isPrime[n]; int x; for ( i = 0; i &lt; n; i++) &#123; isPrime[i] = 1; &#125; for ( x = 2; x &lt; n ; x++) &#123; if ( isPrime[x] )&#123; for ( i = 2; i * x &lt; n; i++) &#123; isPrime[i * x] = 0; &#125; &#125; &#125; for ( i = 2; i &lt; n ; i++) &#123; if ( isPrime[i])&#123; printf(\"%d\\t\", i); &#125; &#125; return 0;&#125; 二维数组格式 数据类型 变量名 [行] [列] 例如int a[3][5]可以理解成a是一个3行5列的矩阵 a[0][0] a[0][1] a[0][2] a[0][3] a[0][4] a[1][0] a[1][1] a[1][2] a[1][3] a[1][4] a[2][0] a[2][1] a[2][2] a[2][3] a[2][4] 遍历与一维数组不同的是,二维数组的遍历需要将行和列都带上,外层是行,内层是列 12345for ( i = 0; i &lt; 3; i++ )&#123; for ( j = 0; j &lt; 5; j++)&#123; a[i][j] = i * j; &#125;&#125; a[x][y]是一个int 代表第x行第y列上的元素 初始化1234int a[][5] = &#123; &#123;0,1,2,3,4&#125;, &#123;10,9,8,7,6&#125;&#125;; 列数是必须指定的,但是行数可以让编译器自己去生成 每行一个{},使用逗号分隔 和一维数组一样,如果省略则按零补上 标上行与列可以定位数组中的元素位置 三维数组…","categories":[],"tags":[{"name":"C","slug":"C","permalink":"https://zhboat.ink/tags/C/"}]},{"title":"C语言笔记(6)","slug":"C语言笔记-6","date":"2020-05-24T10:27:20.000Z","updated":"2020-11-14T05:12:32.205Z","comments":true,"path":"C语言笔记-6/","link":"","permalink":"https://zhboat.ink/C%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0-6/","excerpt":"函数","text":"函数 函数概念函数的存在能让代码复用性更大化,在很多重复的代码中,将重复的部分写成一个自己定义的函数,就只需要在主函数中调用定义函数中的变量去使用就好了 函数是一块代码,接受零个或者多个参数,做某件事情,并返回零个或者一个值 函数定义1234void x (int i)&#123; // 这一整行是函数头,void是返回类型 ,x 是函数名,(int i)是参数表 // 在大括号内的表达式是函数体&#125; 调用函数 调用函数需要在调用它的地方中写上函数名(参数值) () 起到了表达函数调用的重要作用,即使是定义的函数没有参数也需要写上() 如果函数有参数,在调用的时候需要给出正确的数量和顺序 这些传递给参数的值会被按照顺序依次用来初始化函数中的参数 当存在多个参数表的时候,只需要按参数表的顺序去定义就好 函数是知道每一次是哪里调用的,它会返回到正确的地方 能够传递给函数的值是表达式的结果,其中表达式包括[字面量],[变量],[函数的返回值],[计算的结果] 返回值 在函数中出现return时停止函数的执行,并送出一个值 这个值会返回调用函数的地方 虽然一个函数中可以出现多个return,但不管是在表达式中写return; 还是在末尾写return 表达式 都是可以的,但是建议只有单一出口 函数的返回值可以复制给定义函数地方的变量,也可以再次传递给函数,甚至可以丢掉不再使用函数 空返回值 当你需要定义的是没有返回值的函数时,需要把返回类型修改成void 函数名 (参数表) 可以不需要在末尾带上return,如果带上return不能使用带值的return 调用的时候不能做带有返回值的赋值 但是如果函数有返回值,则必须使用带值的return 试试一个用函数实现的求和 求出1~10 20~30 35~45的三个和 1234567891011121314151617#include &lt;stdio.h&gt;void sum(int k, int o) &#123; int i; int sum = 0; for (i = k; i &lt;= o; i++) &#123; sum += i; &#125; printf(\"%d到%d的和是%d\\n\", k, o, sum);&#125;int main() &#123; sum(1, 10); // void sum (int k = 1 ,int o = 10) sum(20, 30); // void sum (int k = 20 ,int o = 30) sum(35, 45); // void sum (int k = 35 ,int o = 45) return 0;&#125; 函数顺序C的编译器是自上而下顺序分析你写的代码 如果需要把定义函数写在main函数之下,需要在main函数之前申明一次 函数原型 函数声明和函数定义的函数类型需要一致 函数头以分号;结尾,就构成了函数的原型 函数原型的目的的是告诉编译器你定义了一个或多个函数,需要调用时需要去寻找 在函数原型中包含了函数名称,函数参数(数量以及类型),还有返回类型 函数原型里不写参数名称也可以正常编译,但是一般为了方便理解代码最好是写上 123456789101112131415161718#include &lt;stdio.h&gt;void sum(int k, int o); // 这一整段叫函数原型 对函数的声明int main() &#123; sum(1, 10); // void sum (int k = 1 ,int o = 10) sum(20, 30); // void sum (int k = 20 ,int o = 30) sum(35, 45); // void sum (int k = 35 ,int o = 45) return 0;&#125;void sum(int k, int o) &#123; // 函数定义 int i; int sum = 0; for (i = k; i &lt;= o; i++) &#123; sum += i; &#125; printf(\"%d到%d的和是%d\\n\", k, o, sum);&#125; 类型转换 调用函数的时给的值如果与参数的类型不一致很可能出现值的差错 因为编译器会自动帮你把类型转换好 如果你想传递的值是double类型,而函数中的参数类型是int,那么会自动转换成int类型 在传递值的时候一定要严格按照函数中的类型去调用 函数传值 C语言在调用函数的时候,永远都只能传递值给函数 每个函数都是一个独立空间,函数中的变量和参数都只存在于这个函数之中,和其他的函数没有任何关系 1234567891011121314151617#include &lt;stdio.h&gt;int swap(int a,int b); // 函数原型int main() &#123; int a = 5; int b = 6; swap(a,b); // swap ( int a = 5, b = 6); printf(\"%d%d\",a,b); // 输出的是主函数中的a，b，与swap函数没有任何联系 return 0;&#125;int swap(int a,int b)&#123; int t = a; a = b; b = t;&#125; 局部(本地)变量 函数的每次运行都会产生一个独立的变量空间,在这个空间中的变量是函数这个运行所独有的,称之为本地变量 只要是在函数中定义的变量都叫做本地变量,参数表中的变量也一样是本地变量 生存期和作用域函数的生存期和作用域起止于大括号内的代码块 生存期: 从这个变量开始出现到它消亡的过程 作用域: 从这个变量在代码中的什么范围内起作用 规则 本地变量定义在块中 可以定义在函数的块中 可以定义在语句的块中 可以定义在任意地方生成的大括号中 程序运行进入定义了变量的块之前,其中的变量不存在,离开这个块的时候,其中的变量就消失了 块外面定义的变量在不同块里面仍然有效 块里面定义了和外面同名的变量就会覆盖外面的变量 不能在同一个块内定义重名的变量 本地变量不会被默认初始化 而参数在进入函数的函数就已经被初始化了 其他 当函数没有参数的时候在原型的参数表中加上void可以明确表示没有任何参数void x (void) 如果实际上有参数而在原型中没写上参数就可能因为传值出现一些奇奇怪怪的问题 在调用函数的时候里面的逗号只是标点符号,如果需要使用逗号运算符需要再加一层括号x((a,b) 函数不允许嵌套定义,但是可以在函数中写另一个函数的原型 int main()也是函数,如果你不需要main有任何参数,也可以在()中加上void","categories":[],"tags":[{"name":"C","slug":"C","permalink":"https://zhboat.ink/tags/C/"}]},{"title":"K680e-G6D1黑苹果","slug":"K680E-G6D1黑苹果","date":"2020-05-21T11:52:00.000Z","updated":"2020-11-14T05:12:32.205Z","comments":true,"path":"K680E-G6D1黑苹果/","link":"","permalink":"https://zhboat.ink/K680E-G6D1%E9%BB%91%E8%8B%B9%E6%9E%9C/","excerpt":"这是一个拼凑了很久才对我而言较为完美的一套配置","text":"这是一个拼凑了很久才对我而言较为完美的一套配置 远景和github也有其他人分享的,但无奈的是,我都不能直接套用 故而升到10.15.410.15.5后自己又拼拼凑凑 (抽了个空更新到了11) 截止0.6.2版本已趋近完美 后续可能会更新吧 下次更新应该是oc正式版了 ^^ 想转成OC,等完善后尝试一下 完善程度 硬件 型号 状态 CPU i5-7400 已睿频 图形卡 HD630 已驱动 图形卡2 GTX 1050Ti 已屏蔽 声卡 ALC269 已驱动 Wi-Fi&amp;蓝牙 自带更换白果卡 BCM94360cs2 USB 内建 休眠 正常 FN映射 正常 显示器 Hidpi已开启 触摸板 正常 已知问题 休眠并不像Win那么完美休眠状态只能开盖或用电源键唤醒 缓冲帧注入的是HD520的ID(不然我开机会黑屏) 电量不能显示插拔电源不能切换状态 亮度调节需要休眠后才正常 触摸板在设置中无法显示(功能正常) 触摸板手势不全 快捷键无法调节亮度 CPU没有低频 ps : 测试来测试去发现是我自己问题🌚… 更新日志更新日志 0x0 … 0x1 修复睡眠更新驱动出于好看把核显仿冒信息改成了UHD 630添加了更多的bug… 0x2 尝试修复亮度调节未果USB修复修复睡眠后时间不同步主板电池没电导致的 0x3 迁移至OC 0.5.9正式版添加CPU传感器驱动添加原生电源管理其他…(忘记了)换成oc后开机快了一倍 ohhhhhh 0x4 oc版本更新至0.6.0 测试版支持macOS 11 beta换成自编译的万能触控板驱动不知道我的设备为啥不能用ps2和rmi…11可用的一键开启hidpibash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/xzhih/one-key-hidpi/master/hidpi.sh)&quot;来自于(https://github.com/mlch911/one-key-hidpi) 0x5 oc版本更新至0.6.1测试版 8.13支持11.0 beta4核显注入ID为19160000 0x6 oc更新至0.6.2正式版刷入D大的BIOS解锁了CFG解锁有风险!!!未解锁机器请将Kernel/AppleCpuPmCfgLcok和AppleXcpmCfgLock修改为True如遇开机黑屏请将ig-platform-id改成19160000核显注入ID修改为591B0000修复亮度调节问题重新定制USB其他优化… 0x7 oc更新至0.6.3正式版支持最新版本BigSur 11.0.1正式版修改仿冒机型信息为14,3更新请先退出AppleID更新驱动版本优化触摸板其他优化… 截图 Intel Power Gadget CPU-s 桌面 关于 设置 电池 Wi-Fi 触摸板 随航 显示器 音量 FaceTime &amp; iMessages 音量&amp;亮度调节 下载蓝奏云 欢迎加入QQ群一起交流讨论981553004 待补充… 镜像来自黑果小兵:https://blog.daliansky.net/WeChat_First-macOS-Catalina-10.15.4-19E2269-official-version-Clover-5116-original-image-reconstruction-version.html 参考:http://bbs.pcbeta.com/forum.php?mod=viewthread&amp;tid=1831835&amp;page=1&amp;ordertype=1#pid50365897 参考:https://blog.xjn819.com/?p=543 参考:https://github.com/usernameOwdxj5/OpenCore-Hasee-K670-i5-9400-W650kj1","categories":[],"tags":[{"name":"黑苹果","slug":"黑苹果","permalink":"https://zhboat.ink/tags/%E9%BB%91%E8%8B%B9%E6%9E%9C/"}]},{"title":"C语言笔记(5)","slug":"C语言笔记-5","date":"2020-05-20T08:30:20.000Z","updated":"2020-11-14T05:12:32.205Z","comments":true,"path":"C语言笔记-5/","link":"","permalink":"https://zhboat.ink/C%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0-5/","excerpt":"基础数据类型","text":"基础数据类型 数据类型C语言必须在使用变量前确定类型并定义 基础类型C语言基础类型表 C语言类型 整数 Char Short Int Long Long long 浮点数 Float Double Long double 逻辑 bool 指针 自定义类型 表达数的范围: char &lt; short &lt; int &lt; float &lt; double 内存占据大小: 1字节~16字节 内存中的表达式: 二进制数(补码) , 编码 输入输出 类型名称 格式化 int %d long %ld double %lf unsinged %u unsigned long long %lu 小于int的类型:char,short,int才用同一种输出格式:%d 大于int的类型:输出格式%ld sizeofsizeof是一个运算符,其用处是给出某个类型或变量在内存中占据的字节数 用法: sizeof(类型/变量) sizeof不会做计算,执行sizeof(int+1.0)会输出double类型的字节数 整数 类型 字节数(1字节=8比特) char 1 short 2 int 取决于CPU long 取决于CPU long long 8 整数的内部表达比int类型小的数据表达的是寄存器中的某些位,而比int大的表达的可能是多个寄存器拼凑起来的,但是不管怎么说,计算机内部都是二进制数 补码从不同角度看是不同的数值 补码的意义就是拿补码和原码可以加出一个溢出的0 负数的补码计算方式0 - a 另一种方式2^n -a,n是这种类型的位数 -1 + 1 = 0 0 –&gt; (1)00000000 1 –&gt; 00000001 (补码-1)11111111 + 00000001 = 100000000 所以-1 + 1 = 00000000 0 - 1 = -1 0 –&gt; (1)00000000 1 –&gt; 00000001 (1)00000000 - 00000001 = 11111111 所以 0 -1 = 补码形式的11111111 整数的范围对于一个字节(8位),可以表达的是从00000000 ~ 11111111 其中00000000 为 0 11111111 ~ 100000000 为 -1 ~ -128 00000001 ~ 01111111 为 1 ~ 127 12345678910#include &lt;stdio.h&gt;int main() &#123; int i = 255; char c = 255; printf(\"i=%d,c=%d\",i,c); return 0;&#125;// i=255,c=-1 由此可见,不同类型的数据的范围是不同的 类型 字节数 范围 char 1字节 -128 ~ 127 short 2字节 -32768 ~ 32767 int 取决于CPU -2^32-1 ~ 2^32-1 -1 Unsigned主要作用是为了移位做纯二进制运算 该类型的整数不以补码形式表示负数,只有正整数和0 表达正数时会将数值扩大一倍 如果一个字面量常数想表达自己是Unsigned,可以在后面加上u或U,例如:255U 整数越界整数是以纯二进制方式进行计算的 11111111 + 1 –&gt; 10000000 = 0 01111111 +1 –&gt; 10000000 = -128 10000000 -1–&gt;01111111 = 127 12345678910#include &lt;stdio.h&gt;int main() &#123; char c = 127; unsigned char c1 = 255; printf(\"c+1=%d,c-1=%d\\nunsingedc+1=%d,unsignedc-1=%d\",c + 1,c - 1,c1 +1, c1 -1); return 0;&#125;// c+1=128,c-1=126// unsinged c+1=256,unsigned c-1=254 选择整数类型 整数之所以有这么多种是为了更准确得表达内存,做底层程序的需要 没有特殊的需求情况下选择int类型就好 Unsigned与否只是输出的不同,但在内部计算仍然是一样的 进制计算机只认识2进制,其他进制的数据都会被转换成2进制 其他进制只是如何把数字表达成字符串,但与内部如何表达数字没有关系 以0开头的数字字面量是8进制 以0x开头的数字字面量是16进制 %o用于将8进制输出10进制,%x/X用于将16进制输出10进制 16进制更适合表达2进制数据,因为4位二进制正好是一个16进制位 浮点类型 类型 字长 范围 有效数字 float 32 ±(1.20×10^-38 ~ 3.40×10^38),0,±inf(无穷大),nan(非数字) 7 double 64 ±(2.2×10^-308 ~ 1.79×10^308),0,±inf(无穷大),nan(非数字) 15 输入输出初始化float类型的变量时,需要在其后面指定f或F后缀来表明是float类型,否则按double来表达 类型 输入 输出 float %f %f,%e/%E(科学计数法) double %lf %f,%e/%E(科学计数法) 精度浮点数的运算没有精度可言 在%和f之间加上.n可以指定输出小数点后n位,这样的输出结果是做4舍5入(向下取整)的 范围当0.0作为除数时,其结果就是无限大,而整数类型的0作为除数时无法编译 printf输出inf 表示超过范围的浮点数:\u0005±∞无穷大 printf输出nan 表示不存在的浮点数 12345678#include &lt;stdio.h&gt;int main() &#123; printf(\"%f\\n\", 1.0 / 0.0); // inf printf(\"%f\\n\", -1.0 / 0.0); // -inf printf(\"%f\\n\", 0.0 / 0.0); // nan return 0;&#125; 选择浮点类型同整数类型一样,选择相对来说范围较大的一个即可 在没有特殊需求的情况下,选择使用double就好 字符之前说过Char是一种整数,但它也是一种特殊的类型:字符 用单引号表示的字符字面量:&#39;x&#39;,1 &#39;&#39;也是一个字符 printf和scanf里用%c来输入和输出字符类型 字符的编码才用ASCII码当输入的是整数类型,输出格式是字符格式时,会对应ASCII码 同一个输入内容,当输出格式不同时会各自表述 12345678#include &lt;stdio.h&gt;int main() &#123; char i = '1'; printf(\"%d\\n\",i); // 49 printf(\"%c\",i); // 1 return 0;&#125; 混合输入当scanf里以空格分割时,输入也需要带上空格 而没有使用空格的情况下,整数后的任意输入都会被记录在后面的char类型里,包括换行符号 字符计算字符也可以做整数的运算,当然输出的也得是字符类型 一个字符加一个数字得到ASCII表中那个数之后的字符 两个字符相减,则得到它们在ASCII表中的距离 例如 123char c = 'A';c++;printf(\"%c\\n\", c); // B 大小写转换 字母在ASCII表中的排列是顺序的 大写字母和小写字母是分开排列的,并不能在一起 a~A 可以得到两段之间的距离,于是: a + &#39;a&#39; - &#39;A&#39;可以把一个大写字母变成小写字母 a + &#39;A&#39;- &#39;a&#39;则可以把一个小写字母变成大写字母 类型转换自动类型转换当运算符两边出现不一致的类型时,会自动转换成能表达范围更大的类型 char –&gt; short –&gt; int –&gt; long –&gt; long long int –&gt; float –&gt; double 对于printf来说,任何小于int的类型都会被转换成int,float会被转换成double 但对于scanf来说,得明确类型大小,要输入short时,需要%hd 强制类型转换当需要把一个量强制转换成另一个较小范围的类型 格式(类型)值(int)2.0 但是小的变量类型不能表达大的值;因为整数越界,所以(short)32768 --&gt; -32768 强制类型转换只是从变量计算出一个新的类型的值,不会改变变量,无论是值还是类型都不会被改变 优先级强制类型转换的优先级高于四则运算 逻辑类型boolbool类型作为非原生类型,需要在头文件加上#include &lt;stdbool.sh&gt;才能使用bool,true,false 真正意义上并没有所谓bool类型,它们仍然是整数 所以输出的时候也只能是输出整数类型的bool 12345678#include &lt;stdio.h&gt;#include \"stdbool.h\"int main() &#123; bool b = true; printf(\"%d\", b); // 1 return 0;&#125; 逻辑运算逻辑运算是对逻辑量进行的运算,结果只有0或1 而逻辑量是关系运算或逻辑运算的结果 不要将赋值,包括复合赋值组合进表达式! 逻辑运算是自左向右进行的,如果左边的结果已经能够决定结果,就不会再做右边的计算了 运算符 描述 示例 结果 ! 逻辑非 !x 如果x是true则结果为false,反之如果x是false则结果为true &amp;&amp; 逻辑与 x &amp;&amp; y 如果x和y都是true,结果就是true,否则任一为false其结果就是false || 逻辑或 x || y 如果x和y有一个是true,结果就是true,只有两者都是false时,结果才是false e.gx ∈(2,5) –&gt; x &gt; 2 &amp;&amp; x &lt; 5 x ∈[3,5] –&gt; x &gt;= 3 &amp;&amp; x &lt;= 5 判断大写字母 x = &#39;A&#39; &amp;&amp; x &lt;= &#39;Z&#39; 判断小写字母 x = &#39;a&#39; &amp;&amp; x &lt;= &#39;z&#39; 优先级这三个逻辑运算的优先级是! &gt; &amp;&amp; &gt; || 而且||和&amp;&amp;是自左向右运算的 !error &amp;&amp; finish || done当error不为0并且finish 或 done有一个为true,那么结果就为true,否则为false 12345678910#include &lt;stdio.h&gt;#include \"stdbool.h\"int main() &#123; bool error = false; bool flish = true; bool done = true; printf(\"%d\",!error &amp;&amp; flish || done); // 1 return 0;&#125; 优先级 运算符 结合性 1 () 从左到右 2 ! + - ++ – 从右到左(单目的+和-) 3 * / % 从左到右 4 + - 从左到右 5 &lt; &lt;= &gt; &gt;= 从左到右 6 == != 从左到右 7 &amp;&amp; 从左到右 8 || 从左到右 9 = += -= *= /= %= 从右到左 其他条件运算符(三目运算符)它的作用和if是一样的,这是编程语言早期遗留下的东西,和if一样可以嵌套使用,不过写法和易懂性很差 条件运算符的优先级高于赋值运算符,但是低于其他的运算符 条件运算符是自右向左结合的 格式:x = y * 5 &gt; 10 ? 3 : 2其中?前面是条件,?后面是条件满足时的值,:后面是条件不满足时的值,如果把它写成if语句就是: 12345if ( y * 5 &gt; 10 )&#123; x = 3;&#125; else &#123; x = 2;&#125; 逃逸字符(转义字符)其作用是为了表达无法输出的控制字符或特殊字符,使用反斜杠\\开头,后面跟上需要逃逸(转义)的字符,这两个字符合起来,组成了一个可以正常输出的字符 字符 别名 作用 \\a 响铃符 触发蜂鸣器 \\b 回车 回退一格 \\t table 到下一个表格位 \\n 回车换行 换行 \\r 回车 回车 \\“ 双引号 将”变成普通字符 \\‘ 单引号 将’变成普通字符 \\\\ 反斜杠 输出反斜杠本身 \\b回退的含义并不是删除前一位字符,而是将\\b后一位字符补进前一位 123456#include &lt;stdio.h&gt;int main() &#123; printf(\"123\\bA\"); // 12A return 0;&#125; \\ttable是每行固定的四个空格,只要输出的字符占据table以内的字符都是按照对齐的方式排列的 一个\\t可以使得输出从下一个制表位开始 用\\t才能使得上下两行对齐 总结类型字节数与范围 类型 存储大小 值范围 char 1 字节 -128 到 127 或 0 到 255 unsigned char 1 字节 0 到 255 signed char 1 字节 -128 到 127 int 2 或 4 字节 -32,768 到 32,767 或 -2,147,483,648 到 2,147,483,647 unsigned int 2 或 4 字节 0 到 65,535 或 0 到 4,294,967,295 short 2 字节 -32,768 到 32,767 unsigned short 2 字节 0 到 65,535 long 4 字节 -2,147,483,648 到 2,147,483,647 unsigned long 4 字节 0 到 4,294,967,295 float 4 或8 字节 1.2E-38 到 3.4E+38 double 8 字节 2.3E-308 到 1.7E+308 long int 4 或 8字节 long long 8字节 long double 8 或 12 或 16字节 3.4E-4932 到 1.1E+4932 运算符优先级 类别 运算符 结合性 后缀 () [] -&gt; . 从左到右 一元 + - ! ~ ++ - - (类型) * &amp; sizeof 从右到左 乘除 * / % 从左到右 加减 + - 从左到右 移位 &lt;&lt; &gt;&gt; 从左到右 关系 &lt; &lt;= &gt; &gt;= 从左到右 相等 == != 从左到右 位与 AND &amp; 从左到右 位异或 XOR ^ 从左到右 位或 OR | 从左到右 逻辑与 AND &amp;&amp; 从左到右 逻辑或 OR || 从左到右 条件 ?: 从右到左 赋值 = += -= *= /= %=&gt;&gt;= &lt;&lt;= &amp;= ^= |= 从右到左 逗号 , 从左到右","categories":[],"tags":[{"name":"C","slug":"C","permalink":"https://zhboat.ink/tags/C/"}]},{"title":"C语言笔记(4)","slug":"C语言笔记-4","date":"2020-04-17T02:26:20.000Z","updated":"2020-11-14T05:12:32.205Z","comments":true,"path":"C语言笔记-4/","link":"","permalink":"https://zhboat.ink/C%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0-4/","excerpt":"for循环","text":"for循环 for格式除了看上去很像while,更像是进阶版的while循环 说是功能等价while循环,倒不如说for循环是计数循环,当你设定一个计数器,初始化数值,在数值到达你设定的某个值之前,不断循环执行循环体内的表达式,而每循环一轮,计数器数值都会按你的设定进行调整 通俗易懂一点就是:对于一开始的初始化条件,每当循环条件成立时,重复循环体内的语句,每轮执行完循环体后,执行每轮的动作,调整计数器的数值 当掌握这三种循环语句后,如何选择它们倒是成了个问题 如果有固定次数,使用for 如果必须执行一次用do_while 其他情况才用while for循环格式每个表达式都是可以省略的 for ( ;循环条件; ) == while ( 循环条件 ) 123for ( 初始化条件; 循环条件; 每轮的动作 )&#123; 循环体&#125; 代码示例 阶乘 所谓阶乘就是n!,其结果是1*2*3*4*5*...*n 使用代码实现这一过程,让用户输入n的值,然后计算出n!的结果 (需要注意的是,在做求和的程序时,初始化变量为0,而在做求积的变量时,初始化变量应该为1) 首先使用while来实现 12345678910111213141516171819202122/* * 定义变量n，i，fact * n的值是用户自行输入的 * i不断的从1递增到n * fact保存计算结果 * 当i小于或等于用户输入值n后结束循环 * 循环体内fact的值就是1*2*3*...*n的算法 * 每循环一次i++*/#include &lt;stdio.h&gt;int main() &#123; int n; int fact = 1 ; int i = 1; scanf(\"%d\", &amp;n); while ( i &lt;= n )&#123; fact *= i; i ++; &#125; printf(\"%d!=%d\", n, fact); return 0;&#125; 我们改成for循环 循环控制变量i只在for循环表达式中被使用,所以能将定义变量i写在for循环中,但要注意的是,在初始化条件处定义变量只有C99才能使用 1234567891011121314151617181920/* * 定义变量n，fact * n的值是用户自行输入的 * fact保存计算结果 * 定义变量i并初始化 * 当i小于或等于n时进入循环体 * 每进行一轮循环让i++ * 直到循环条件不满足i小于或等于n*/#include &lt;stdio.h&gt;int main() &#123; int n; int fact = 1 ; scanf(\"%d\", &amp;n); for ( int i = 2; i &lt;= n; i++ ) &#123; fact *= i; &#125; printf(\"%d!=%d\", n, fact); return 0;&#125; 换个思路想,如果从n乘到1还能实现该功能吗? 123456789101112131415161718192021/* 一： * 定义变量n，i，fact * n的值是用户自行输入的 * i的值保存用户输入的n * fact保存计算结果 * 循环体内fact的值就是n*n-1...的算法 * 每循环一次n-- * 当n的值小于或等于1就结束循环*/#include &lt;stdio.h&gt;int main() &#123; int n; int fact = 1 ; scanf(\"%d\", &amp;n); int i = n; for ( ; n &gt; 1; n--) &#123; fact *= n; &#125; printf(\"%d!=%d\", i, fact); return 0;&#125; 素数 当用户输入一个数时,判断其是否为素数 仅输出1到100范围内的前20个素数 所谓素数即只能被1或自己整除的数,例如2,3,5,7,11,13,17,19... 1在狭义的范围中不算是素数,所以在此不列举1为素数 break的作用是跳出整个循环,另一个其他的用法是continue,但是它的意义只是跳过后续的循环体,回到for循环开头 ||意为或者,用于多个条件判断时,只要满足其一即true,任一条件不满足即false &amp;&amp;意为且,用于多个条件判断时,当所有条件同时满足时即true,否则false 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/* * 定义用户输入变量x * 定义判断条件变量isPrime * 定义并初始化i的值为2 * 当i的值小于用户输入x时进行循环判断 * 每当循环结束就让i的值自增 * i &lt; x 可以理解成i的值永远都是x - 1 * 如果x余i的值为0的话就将isPrime的值变成0 * 并跳出整个循环 * 判断isPrime的值是1还是0 * 如果为0或者x为1，就输出不是素数 * 否则输出是素数*/#include &lt;stdio.h&gt;int main() &#123; int x; int isPrime = 1; scanf(\"%d\", &amp;x); for (int i = 2; i &lt; x; i++) &#123; if (x % i == 0) &#123; isPrime = 0; break; &#125; &#125; if (isPrime == 0 || x == 1) &#123; printf(\"%d不是素数\", x); &#125; else &#123; printf(\"%d是素数\", x); &#125; printf(\"\\n\\n在100以内的前50个素数有:\\n\"); secondary(); return 0;&#125;/* * 定义变量x，使用循环实现x的值是从1到100 * 定义变量time，限制time为20 * 定义变量isPrime，用于记录是否为素数 * 定义变量i，用于判断是否为素数 * 初始化x的值为1，初始化计数器time为0 * 在1到100中当计数器小于20时，执行循环体内的语句 * 每当有一个素数产生时，让计数器的数+1 * 每五个素数换行显示，并让所有数都对齐*/int secondary() &#123; for (int x = 1, time = 0; x &lt;= 100 &amp;&amp; time &lt; 20; x++) &#123; int isPrime = 1; for (int i = 2; i &lt; x; i++) &#123; if (x % i == 0) &#123; isPrime = 0; &#125; &#125; if (isPrime == 1 &amp;&amp; x != 1) &#123; time++; printf(\"%d\\t\", x); if (time % 5 == 0) &#123; printf(\"\\n\"); &#125; &#125; &#125; return 0;&#125; 枚举硬币 用1角,2角,五角的硬币凑出10元以下的金额 我看到这题愣了半天没想明白应该怎么实现,无奈看完整个视频才缕清思路 12345678910111213141516171819202122232425/* * 变量x为用户输入值 * one为一角，two为二角，five为五角 * one至多循环x*10-1次，two至多循环x*10\\2-1次，five至多循环x*10/5-1次 * 当循环的过程中，满足了one+two*2+five*5等于x*10 * 就输出结果，否则就继续循环 * goto可以指定跳转到任意处*/#include &lt;stdio.h&gt;int main() &#123; int x; scanf(\"%d\", &amp;x); for (int one = 1; one &lt; x * 10; one++) &#123; for (int two = 1; two &lt; x * 10 / 2; two++) &#123; for (int five = 1; five &lt; x * 10 / 5; five++) &#123; if (one + two * 2 + five * 5 == x * 10) &#123; printf(\"%d个1角加%d个2角加%d个5角可以得到%d元\", one, two, five, x); goto exit; &#125; &#125; &#125; &#125; exit: return 0;&#125; f(n) f(n) = 1+1/2+1/3+1/4+…+1/n 计算出1/1~1/n所有数的和 12345678910111213141516171819/* * 定义整型变量n，用户输入值 * 定义浮点变量sum。求和记录数 * 定义整型变量x，循环计数器 * 当x小于等于用户输入数时，x的值从1开始 * sum的值等于sum加上1/x * 每轮循环结束x的值都会加1*/#include &lt;stdio.h&gt;int main() &#123; int n; scanf(\"%d\", &amp;n); double sum = 0.0; for (int x = 1; x &lt;= n ; x++) &#123; sum += 1.0 / x ; &#125; printf(\"f(%d)=%f\", n, sum); return 0;&#125; 如果f(n)=1-1/2+1/3-1/4+1/5…+1/n呢? 实现方式也很简单的,只需要定义一个浮点类型的变量,初始值等于1,当每次循环结束前,将这个浮点类型的变量变成负数,修改分母为这个变量即可 123double z = 1.0;sum += z / x;z = -z;","categories":[],"tags":[{"name":"C","slug":"C","permalink":"https://zhboat.ink/tags/C/"}]},{"title":"C语言笔记(3)","slug":"C语言笔记-3","date":"2020-04-13T14:50:20.000Z","updated":"2020-11-14T05:12:32.205Z","comments":true,"path":"C语言笔记-3/","link":"","permalink":"https://zhboat.ink/C%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0-3/","excerpt":"程序代码记录(习题)","text":"程序代码记录(习题) 猜数游戏 让计算机来存储一个数,然后让用户来猜,每当用户输入一个数,计算机就输出该数大于或小于用户输入的数,直到用户猜中为止,最后还要输出用户一共猜了多少次 思路: 随机数 添加一个整型变量,它的值为随机数 x % n 的结果是[0,n-1]的整数 用户输入数 用户输入的值需要写在循环体内 计数器 计数器需要写在判断前,无论是否做出判断,只要用户做出了”猜”的动作,就让计数器++ 判断 循环体中需要写一段判断条件: 用户输入的数大于指定数值时,输出”大于该数” 而当用户输入的数小于指定数值时,输出”小于该数” 结束条件 只有当条件成立时,才会结束循环 不要按照人的思维来理解循环条件 (?) 并输出变量值 思路实现:如果需要用到随机数需要引用两个库stdlib.h和time.h 12srand(time(0));int random = rand() %100 +1; 只需要取100以内的数,随机数 % 100 为 0-99,+1的操作让其为100以内 用户的猜数操作需要写在循环体中 12int input;scanf(\"%d\", &amp;input); 定义一个计数器,让它用户输入数值后++,以满足每次”猜数”的操作能记录 12int time = 0;time++; 用户输入的数大于指定数值时,输出”大于该数” 而当用户输入的数小于指定数值时,输出”小于该数” 12345 if ( input &gt; random )&#123; printf(\"您输入的数大于随机数\"); &#125; else if ( input &lt; random )&#123; printf(\"您输入的数小于随机数\");&#125; 结束的条件是当用户输入数等于随机数才跳出循环,在代码中的实现却得写成这样 1while ( input != random ); 当输入值不等于随机数时继续循环,只有输入值等于随机数才会结束循环 代码:1234567891011121314151617181920212223242526272829/* * 定义一个随机数 * 定义一个计数器 * 定义一个用户输入值 * 无论是否做出判断都会执行一次输入值的动作，所以使用do while * 将用户输入值的操作写在循环体中，而后让计数器++ * 判断输入值是否大于或等于随机数 * 不满足条件时结束循环*/#include &lt;stdio.h&gt;#include \"stdlib.h\"#include \"time.h\"int main() &#123; srand(time(0)); int random = rand() %100 + 1; int input; int time = 0; do &#123; scanf(\"%d\", &amp;input); time++; if ( input &gt; random )&#123; printf(\"您输入的数大于随机数\"); &#125; else if ( input &lt; random )&#123; printf(\"您输入的数小于随机数\"); &#125; &#125;while ( input != random ); printf(\"您猜中了！您一共猜了%d次\", time);&#125; 算平均数 让用户输入一系列正整数,当用户输入-1时结束输入,然后程序计算出这些数字的平均数,输出用户输入数字的个数与平均数 思路: 用户输入数 除了需要用户输入外,还需要定义一个存储这些数的变量 计数器 每当用户输入数字之后就进行++的操作 但当用户输入结束指令时也会被记录,所以要在循环体外让计数器-1 结束 不满足条件时结束循环 思路实现: 循环条件 满足循环的条件是当用户输入的值不为-1 1while ( input !&#x3D; -1) 用户输入数 用户输入的值需要写在循环体内 12int input;scanf(\"%d\", &amp;input); 计数器 计数器需要写在用户输入后面,每当用户输入后都进行++的操作 但是在结束循环体后要让计数器-1 123int time = 0;time ++;time -= 1; 存储数值 计算平均数需要让用户输入的所有数相加并除以输入次数,所以存储变量需要每次都在原有基础上加上用户新输入的数 12int sum = 0;sum += input; 代码:12345678910111213141516171819202122232425262728293031/* * 定义input time sum 变量 * 分别对应用户输入值，计数器，和用户输入值总和 * 当用户输入的值不为-1时进入循环 * sum的值为input+sum * 每次用户输完数后计数器都会++，即使是-1 * 所以要在结束循环后让计数器-1，让其变成正常的 * 最后输出计数器和平均值*/#include &lt;stdio.h&gt;int main() &#123; int input , time , sum; time = 0; input = 0; sum = 0; while ( input != -1)&#123; sum += input; scanf(\"%d\", &amp;input); time++; &#125; time -= 1;// 另一种实现方式// scanf(\"%d\", &amp;input);// while ( input != -1)&#123;// time++;// sum += input;// scanf(\"%d\", &amp;input);// &#125; printf(\"您一共输入了%d次，最后的平均数是：%d\", time , sum / time); return 0;&#125; 整数逆序 当用户输入任意数字后,计算机需要输出其对应的倒序 思路: 对整数做%10的操作就能得到个位数 对整数做/10的操作就能去掉个位数 代码:12345678910111213141516171819/* * 定义变量x和digit * 当用户输入x的值后进入while * 首先会判断x是否大于0，满足则进入循环体 * digit的值是用户输入的最后一位 * 然后将去掉的那一位数去掉，重新循环 * 知道x的值不满足大于0的条件才会结束循环*/#include &lt;stdio.h&gt;int main() &#123; int x , digit; scanf(\"%d\", &amp;x); while ( x &gt; 0)&#123; digit = x % 10; printf(\"%d\", digit); x /= 10; &#125; return 0;&#125; 整数分解 输入一个非负整数,正序输出它每一位数字,并在其后面加空格 输入:12345 输出:1 2 3 4 5 思路:123456789(input)12345 &#x2F; (mask)10000 &#x3D; (result)1(input)12345 % (mask)10000 &#x3D; 2345(mask)10000 &#x2F; 10 &#x3D; (mask)1000(input)2345 &#x2F; (mask)1000 &#x3D; (result)2(input)2345 % (mask)1000 &#x3D; 345(mask)1000 &#x2F; 10 &#x3D; (mask)100...如此循环,直至mask&#x3D;0 取位数(mask) 之前写过取位数的相关代码,但是仅仅只是取位数而已,这里我们需要每取一位就让input除等以10,mask乘等以10,直到input被除到小于等于10为止 算法实现 得知mask的值之后就好办了,根据上述算法就可以写出代码了 判断,当mask大于1就输出一个空格 代码:12345678910111213141516171819202122232425#include &lt;stdio.h&gt;int main() &#123; int inp; scanf(\"%d\", &amp;inp); int inp2 = inp; int mask = 1;// 取位数 while ( inp &gt; 9 )&#123; inp /= 10; mask *= 10; &#125; printf(\"mask=%d\\n\", mask);// 算法 do &#123; int res = inp2 / mask; printf(\"%d\", res); if ( mask &gt; 1 )&#123; printf(\" \"); &#125; inp2 %= mask; mask /= 10; &#125;while ( mask &gt; 0 ); return 0;&#125; 最大公约数 输入两个数a和b,输出它们的最大公约数 例如:输出12 和18 输出6 思路: 如果b等于0,结束计算,a就是最大公约数; 计算a除b的余数,让a等于b,而b等于那个余数 代码:1234567891011121314#include &lt;stdio.h&gt;int main() &#123; int a, b; scanf(\"%d %d\", &amp;a, &amp;b); while (b != 0) &#123; int t = a % b; a = b; b = t; printf(\"%d%d%d\\n\",a,b,t); &#125; printf(\"gcd=%d\", a); return 0;&#125; 给定条件整数集 给定一个不超过6的正整数A,从A开始的连续4个数字算进整数集中,请输出由整数集中的所有无重复数字组成的3位数 要求输出的3位数从大到小排列,每行只存在6个整数,每个整数之间用空格分开,但是航模不允许有多余的空格 思路: 嵌套的三个循环,每个数对应一个变量 输出条件,当三个数字不相同的时候才输出结果 换行条件,满足循环6的次数,满足则换行,否则输出空格 代码:123456789101112131415161718192021222324252627282930313233343536/* * 定义五个变量 * a是用户输入值 * i，j，k分别对应整数集中的三位数 * time是计数器，每轮输出判断中让计数器++ * 循环条件把用户输入的值赋给i，j，k，当它们小于等于3时才进入循环每轮循环让它们+1 * 只有当i，j，k三个数互不相等时才满足输出判断 * 如果计数器到达6次时，输出一个换行，并让计数器归零 * 否则的话只输出空格符 * */#include &lt;stdio.h&gt;int main() &#123; int a, i, j, k, time = 0; scanf(\"%d\", &amp;a);// 嵌套循环 for (i = a; i &lt; a + 4; i++) &#123; for (j = a; j &lt; a + 4; j++) &#123; for (k = a; k &lt; a + 4; k++) &#123;// 输出判断 if (i != k &amp;&amp; i != j &amp;&amp; j != k) &#123; time++; printf(\"%d%d%d\", i, j, k);// 换行判断 if (time == 6) &#123; printf(\"\\n\"); time = 0; &#125; else &#123; printf(\" \"); &#125; &#125; &#125; &#125; &#125; return 0;&#125; 水仙花数 水仙花数是指一个N位的正整数(N&gt;=3),它的每个位上的数字N次幂之和等于它本身的,计算出所有N位的水仙花数 例如:153=1^3+5^3+3^3,输入3,输出153,370,371 思路: 先利用循环得出N位数的最小数,例如n为3,则最小数为100 其次一个大循环,范围是最小数到最大数(最小数*10) 将所有数都拆分开计算,每个数都乘n次自身,使用sum储存它们的和 判断,当sum与大循环的条件相等时,就为水仙花数 代码:1234567891011121314151617181920212223242526272829303132//水仙花数是指一个N位的正整数（ N&gt;=3 ），它的每个位上的数字的N次幂之和等于它本身,计算出所有N位水仙花数#include &lt;stdio.h&gt;int main() &#123; int n, first = 1; scanf(\"%d\", &amp;n); if (n &lt; 3 || n &gt; 7) &#123; printf(\"您输入的数有误,请重新输入\"); &#125; else &#123; for (int i = 1; i &lt; n; i++) &#123; first *= 10; &#125; //k = first~first*10 for (int k = first; k &lt; first * 10; ++k) &#123; int sum = 0; for (int p = k; p &gt; 0;) &#123; int o = 0; o = p % 10; // o = 100 ~ 999 % 10 int res = o; p /= 10; // first~first*10/10 for (int j = 1; j &lt; n; j++) &#123; //循环两次 res *= o;// res * res * res &#125; sum += res; //sum = sum + res * res * res &#125; if (k == sum) &#123; printf(\"%d\\n\", sum); &#125; &#125; &#125; return 0;&#125; 九九乘法表 完整口诀表 对任意给定的1位正整数N,输出从11到n\\n的下三角部分口诀表,结果后面需要占四位空格,左对齐显示 思路: 两个循环,第一个范围从1到输入的正整数N,每循环一轮+1 第二个循环从1到上一个变量的数,实现递减 还需要有个判断,当结果是个位数时打印四个空格,否则输出三个空格 代码:12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;int main() &#123; int n; scanf(\"%d\", &amp;n); // 判断n的大小 if (n &lt; 1 || n &gt; 9) &#123; printf(\"范围是1~9，请重新输入\"); &#125; else &#123; // 从1到n循环 for (int i = 1; i &lt;= n; i++) &#123; // 从1到i循环 for (int j = 1; j &lt;= i; j++) &#123; int sum; sum = i * j; // 当和是个位数时打印四个空格 if (sum &lt; 10) &#123; printf(\"%d*%d=%d \", j, i, sum); // 大于个位数时打印三个空格 &#125; else if (sum &gt;= 10) &#123; printf(\"%d*%d=%d \", j, i, sum); &#125; &#125; printf(\"\\n\"); &#125; &#125; return 0;&#125; 统计素数求和 统计给定整数M和N区间内素数的个数,并对它们求和 输入M和N,以空格分开,范围是1&lt;=M&lt;=N&lt;=500 思路:之前做过100以内的50个素数,判断方法直接照搬就行 添加一个求和的操作就行 代码:12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;int main() &#123; int m, n; scanf(\"%d %d\", &amp;m, &amp;n); if (m &lt; 1 || n &gt; 500) &#123; printf(\"请重新输入\"); &#125; else &#123; if (m == 1) &#123; m = 2; &#125; int time = 0; int sum = 0; for (int i = m; i &lt;= n; i++) &#123; int isPrime = 1; for (int k = 2; k &lt; i; k++) &#123; if (i % k == 0) &#123; isPrime = 0; break; &#125; &#125; // 判断是否为素数 if (isPrime) &#123; time++; sum += i; &#125; &#125; printf(\"%d %d\", time, sum); &#125; return 0;&#125; 猜数游戏2 猜数游戏是让系统随机产生一个100以内的正整数,用户输入一个数对其猜测,编写程序让输入数字与产生的随机数进行对比较,如果大了提示”Too big!”,如果小了提示”Too small”,相等表示猜到了 如果猜到的话,程序结束,并统计猜数的次数 如果1次就猜中了就提示”Bingo!”,三次以内猜中该随机数则提示”Lucky You!”,如果超过三次但是在N(N &gt; 3)次以内(包括第N次)猜到该随机数则提示”Good Guess”,如果超过N次都没猜到或者在没到达N次之前用户输入了一个负数,提示”Game Over!”,并结束程序 输入格式:在第一行输入两个不超过100的正整数,分别是第一次用户的输入,以及猜测的最大次数N,随后每行给出一个用户的输入 输出格式:在一行中输出每次猜测相对应的结果,直到输出才对的结果或是”Game Over”则结束 思路:if 造它就完了,奥利给! 100以内正整数随机数 循环次数,判断条件,计数器 代码:123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;#include \"stdlib.h\"#include \"time.h\"int main() &#123; // 生成随机数 srand(time(0)); int random = rand() % 100 + 1; int i, j, time; // 第一次猜测以及最大猜测次数输入 scanf(\"%d %d\", &amp;i, &amp;time); // 循环100次 for (j = 0; j &lt; 100 ; j++) &#123; // 如果满足i是负数或者循环次数比最大猜测数大 if (i &lt; 0 || j &gt; time) &#123; printf(\"Game Over!\"); break; &#125; if (i &lt; random) &#123; printf(\"Too small\\n\"); &#125; else if (i &gt; random) &#123; printf(\"Too big\\n\"); &#125; else &#123; // 相等的各种情况 if (j == 0) &#123; // 一次猜中 printf(\"Bingo!\\n\"); break; &#125; else if (j &lt;= 3) &#123; // 三次内 printf(\"Lucky You!\"); break; &#125; else if (j &gt; 3 &amp;&amp; j &lt; time) &#123; // 超过三次,但是不超过最大猜测数 printf(\"Good Guess!\"); break; &#125; &#125; // 每轮循环重新输入猜测数 scanf(\"%d\", &amp;i); &#125; return 0;&#125; 前N项和 计算序列2/1+3/2+5/3+8/5+...的前N项之和 序列从2开始,每一项的分子是前一项分子与分母的和,分母是前一项的分子 输入格式:输入一个正整数N 输出格式:输出部分和的值,精确到小数点后两位,计算结果不超过双精度范围 思路: 循环,根据输入值N的范围 算法: 1234 j k 2&#x2F; 1j &#x3D; t &#x3D; j + k;k &#x3D; j; 3 &#x2F; 2 双精度double,小数点后两位%.2f 代码:12345678910111213141516#include &lt;stdio.h&gt;int main() &#123; int n; scanf(\"%d\", &amp;n); double j = 2.0, t = 0.0, k = 1.0, sum = 0.0; for (int i = 0; i &lt; n; i++) &#123; sum += j / k; // 临时值t t = j + k; k = j; j = t; &#125; printf(\"%.2f\",sum); return 0;&#125; 约分最简公式 分数可以表示为”分子/分母”的形式,用户输入一个分数时,将其约分成最简约分式,最简分式指分子和分母不具有继续约分的能力 当分子大于分母时,不需要表达成整数又分数的形式,原样输出就行,而当分子分母相等时表示为1/1的分数形式 输入格式:输入正整数w分数,分子与分母之间以/分割 在scanf的格式字符串值加入/就能让scanf来处理斜杠 输出格式:格式与输入相同,对应分数最简分式 思路:之前做过最大公约数来着 代码:1234567891011121314#include &lt;stdio.h&gt;int main() &#123; int x,y; scanf(\"%d/%d\",&amp;x,&amp;y); int a = x , b = y; while ( b != 0)&#123; int t = a % b; a = b; // a为最大公约数 b = t; &#125; printf(\"%d/%d\",x/a,y/a); return 0;&#125;","categories":[],"tags":[{"name":"C","slug":"C","permalink":"https://zhboat.ink/tags/C/"}]},{"title":"多平台hexo","slug":"多平台hexo","date":"2020-04-10T10:12:20.000Z","updated":"2020-11-14T05:12:32.205Z","comments":true,"path":"多平台hexo/","link":"","permalink":"https://zhboat.ink/%E5%A4%9A%E5%B9%B3%E5%8F%B0hexo/","excerpt":"你不会还在本地部署hexo吧?","text":"你不会还在本地部署hexo吧? 众所周知,用hexo+gitpage能搭建很不错的博客,但是有个比较致命的缺点,不方便跨平台部署,当然你也可以选择将其部署至服务器,或者压缩拷贝 就连backup插件也还是得需要在本地安装nodejs等服务,可谓是让人觉得头疼 这些问题遇到CI都可以迎刃而解,除了人尽皆知的Travis-CI,另一个不错的方案是使用GithHub提供的Action,相信我,用过它的人都说好 虽说过程有些麻烦,但是可以一劳永逸的解决多端设备都能快速部署hexo 创建私有库 密钥对上篇文章讲过啦创建秘钥对 初始化仓库在本地博客路径执行hexo clean,然后复制这些文件到一个新目录,除了node_modules 新目录中初始化git仓库git init,然后连接至远程仓库git remote add origin 仓库地址 然后git push -u origin master上传到远程仓库 添加Secrets在仓库–&gt;setting–&gt;Secrets里添加一个DEPLOY_KEY内容是你本地私钥,用cat ~/.ssh/rsa查看,并整段复制 Action点击私有库中的Action 然后点击Set up a workflow yourself 然后复制粘贴到输入框,注意修改user_name: 你的github用户名 user_email: 你的github邮箱 SOURCE_REPO: &quot;原仓库(gitpage)&quot; SOURCE_BRANCH: &quot;分支&quot; DESTINATION_REPO: &quot;目标仓库&quot; DESTINATION_BRANCH: &quot;分支&quot;这些变量为你自己的信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748name: Deployon: [push]jobs: build: runs-on: ubuntu-latest name: deploy hexo steps: - name: Checkout uses: actions/checkout@v1 with: submodules: true # 使用缓存加速nodejs的安装,如果超过七天没有访问,就会删除缓存# npm插件会读取package.json来安装 - name: Cache node modules uses: actions/cache@v1 id: cache with: path: node_modules key: $&#123;&#123; runner.os &#125;&#125;-node-$&#123;&#123; hashFiles('**/package-lock.json') &#125;&#125; restore-keys: | $&#123;&#123; runner.os &#125;&#125;-node- - name: Install Dependencies if: steps.cache.outputs.cache-hit != 'true' run: npm install # 部署hexo - name: Deploy id: deploy uses: sma11black/hexo-action@v1.0.0 with: deploy_key: $&#123;&#123; secrets.DEPLOY_KEY &#125;&#125; user_name: 你的github用户名 user_email: 你的github邮箱# 同步至coding,不需要可以删除这段 - name: Sync uses: wei/git-sync@v1.1.2 env: SOURCE_REPO: \"原仓库(gitpage)\" SOURCE_BRANCH: \"分支\" DESTINATION_REPO: \"目标仓库\" DESTINATION_BRANCH: \"分支\" SSH_PRIVATE_KEY: $&#123;&#123; secrets.DEPLOY_KEY &#125;&#125; with: args: $SOURCE_REPO $SOURCE_BRANCH $DESTINATION_REPO $DESTINATION_BRANCH 过一会就能看到Action通过了(我忘记把_config里coding去掉了) 当写完workflow后别忘记在本地git pull(,或你在本地写完再git push也是一样) 配置一定要规范_config!!! e.g 1234deploy: type: git repo: git@github.com:zhboat/zhboat.github.io branch: master CNAME和README的处理CNAME和README直接丢到source文件夹内就行,如果你的README是md格式,请在_config.yml里添加一行skip_render: README.md 后续换设备的话只需要从github克隆仓库后就行,无需再安装nodejs 在source/_posts里新建xx.md,写完文章后push到仓库就能自动部署 其实这样部署有个弊端就是gitpage的commit会清空 但是懒癌患者也不会去看commit的^ ^ 比懒可没人赶得上我说起懒,咱就觉得git add . git commit -m git push这三条命令敲下来比hexo g -d来的更麻烦了,这可太不妙了 脚本可是万能的😉 新建个sh 12345678910#!/bin/bashCURTIME=$(date +\"%Y-%m-%d\")-$(stat $BLOG_DIR |awk &#123;'print $11'&#125;)BLOG_DIR=($HOME/Desktop/blog)cd $BLOG_DIRgit add .git commit -m \"✏️Last updated at: $CURTIME\"git push osascript ~/Jio本/tips.scpt 修改fish的函数 123function push sh ~&#x2F;Jio本&#x2F;push.shend 用脚本编辑器添加个AppleScript 1display dialog &quot;上传成功&quot; buttons &#123;&quot;OK&quot;&#125; default button 1 巴适得很~ ؏؏☝ᖗ乛◡乛ᖘ☝؏؏ 参考https://www.cnblogs.com/deppwang/p/12326906.html git-sync:https://github.com/marketplace/actions/git-sync-action hexo-action:https://github.com/marketplace/actions/hexo-action","categories":[],"tags":[{"name":"github","slug":"github","permalink":"https://zhboat.ink/tags/github/"},{"name":"hexo","slug":"hexo","permalink":"https://zhboat.ink/tags/hexo/"}]},{"title":"C语言笔记(2)","slug":"C语言笔记-2","date":"2020-04-07T10:48:33.000Z","updated":"2020-11-14T05:12:32.205Z","comments":true,"path":"C语言笔记-2/","link":"","permalink":"https://zhboat.ink/C%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0-2/","excerpt":"while循环","text":"while循环 while和if有着相似的用法,但是当需要做很多次的判断时,会使用更高效率的while语句,与if不同的是,当条件满足判断时,不断重复循环体内的语句 while格式循环体内一定要有改变条件判断的机会,否则会陷入死循环 while 写法与if类似,条件满足就执行表达式的内容,条件不满足时就结束循环,所以当条件不满足时,while内的表达式一次都不会执行 123while ( 条件判断 )&#123; 表达式(循环体)&#125; do while 虽然看着与while很像,但区别在于do while会在进入循环时不做条件判断,而是在执行完表达式后再检查循环的条件是否满足,如论如何都会进行一次表达式的执行,如果满足则进行下一次循环,不满足时才会结束循环 123do &#123; 表达式(循环体)&#125;while (条件判断); 代码示例 取位数 如果我们输入一串正整数,当机器得到这串数字时,需要得出这串整数一共有多少位,如果使用if进行判断,那么代码会显得十分臃肿且繁琐,先看看用if是如何实现 if: 123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;int main() &#123; int x; int n = 0; // 定义整数x和n scanf(\"%d\",&amp;x); // 用户输入值为x n++; // n自加1,满足0的条件 x /= 10; // 让x数值减少一位 /* * 判断 * 当x大于0时，使n的值加1，并减去x的个位数 * 直至x小于0时,才结束判断,并输出n的值*/ if ( x &gt; 0)&#123; n++; x /= 10; if ( x &gt; 0)&#123; n++; x /= 10; if ( x &gt; 0)&#123; n++; x /= 10; &#125; &#125; &#125; printf(\"%d\\n\",n); return 0;&#125; 可以看到上述代码又啰嗦又麻烦,而且还只能计算到四位数,进而可以使用while来实现 while: 1234567891011121314151617181920/* * 循环判断 * 当x 大于 0时，使n的值加1 * 然后让x的值除以10（去掉个位数） * 直到x不满足x&gt;0这个判断，才会跳出while循环*/#include &lt;stdio.h&gt;int main() &#123; int x; int n = 0; scanf(\"%d\",&amp;x); n++; x /= 10; while ( x &gt; 0)&#123; n++; x /= 10; &#125; printf(\"%d\\n\",n); return 0;&#125; do while: 1234567891011121314151617/* * 使用do-while语句来进行循环的一特点就是 * 无论如何都会执行一次循环体 * 所以即便用户输入的值是0，也可以正常计算出位数*/#include &lt;stdio.h&gt;int main() &#123; int x; scanf(\"%d\", &amp;x); int n = 0; do&#123; x /= 10; n++; &#125; while ( x &gt; 0 ); printf(\"%d\", n); return 0;&#125; 通过举一反三,让负数也计算其位数的话只需要添加个if判断即可 1234567891011121314151617181920212223242526/* * 判断x是否大于等于0 * 如果满足上列条件就进行循环 * 否则按负数来计算 * 将x的值变成正整数来继续完成循环体*/#include &lt;stdio.h&gt;int main() &#123; int x; scanf(\"%d\", &amp;x); int n = 0; if ( x &gt;= 0) &#123; do &#123; x /= 10; n++; &#125; while ( x &gt; 0 ); &#125; else&#123; x += +x; do &#123; x /= 10; n ++; &#125;while ( x &lt; 0 ); &#125; printf(\"%d\", n); return 0;&#125; Log2X 计算x是2的多少次方 123456789101112131415161718192021/* * 定义变量x和ret * 初始化ret为0 * 将x的值赋值给b * 当x大于1时进入循环体 * 循环体内x的值为x除2，并让ret加1 * 当x不满足大于1时退出循环*/#include &lt;stdio.h&gt;int main() &#123; int x; int ret = 0; scanf(\"%d\", &amp;x); int b = x ; while ( x &gt; 1)&#123; x /= 2; ret++; &#125; printf(\"log2 of %d is %d\", b, ret); return 0;&#125; 倒计时 输出用户输入到0的所有整数 123456789101112131415161718/* * 初始化coun的值 * 当count大于0时进入循环体 * 进入循环体后首先让count减1 * 而后输出count的值 * 当count不满足条件判断时结束循环*/#include &lt;stdio.h&gt;int main() &#123; int count = 0; scanf(\"%d\", &amp;count); while ( count &gt; 0 )&#123; count--; printf(\"%d\\n\", count); &#125; printf(\"发射！\"); return 0;&#125;","categories":[],"tags":[{"name":"C","slug":"C","permalink":"https://zhboat.ink/tags/C/"}]},{"title":"免费图床","slug":"免费图床","date":"2020-03-26T07:38:20.000Z","updated":"2020-11-14T05:12:32.205Z","comments":true,"path":"免费图床/","link":"","permalink":"https://zhboat.ink/%E5%85%8D%E8%B4%B9%E5%9B%BE%E5%BA%8A/","excerpt":"利用GitHub+repo-sync+jsDelivr+uPic搭建的免费图床","text":"利用GitHub+repo-sync+jsDelivr+uPic搭建的免费图床 鉴于PicGo在我设备上一直出现”上传失败’’的情况,所以我将其换成了uPic,借此写下这篇随记 GitHub首先创建一个公开项目,可以取任何名称 这是我的项目,欢迎参考 Git Sync使用该功能是为了让github项目自动同步到coding或gitee,虽说现在有免费的jsDelivr起到cdn加速作用,但谁能保证这玩意不会哪天突然挂了:| 咱本着懒癌精神,打算用最自动化的方式来实现,于是咱摸索出偶然间发现了别人项目中的这一十分强大的功能–Action,具体玩法咱就不过多叙述了 此项目得益于github官方提供的Action服务,在Marketplace里可以搜索的到,使用起来也是非常的方便 项目地址: git sync 用法(参考官方wiki): 在本地项目中创建.github/workflows/xxx.yml 123456789101112131415on: pushjobs:repo-sync:runs-on: ubuntu-lateststeps: - name: repo-syncuses: wei/git-sync@v1env: SOURCE_REPO: \"源仓库\" SOURCE_BRANCH: \"源分支\" DESTINATION_REPO: \"目标仓库\" DESTINATION_BRANCH: \"目标分支\" SSH_PRIVATE_KEY: $&#123;&#123; secrets.SSH_PRIVATE_KEY &#125;&#125;with: args: $SOURCE_REPO $SOURCE_BRANCH $DESTINATION_REPO $DESTINATION_BRANCH 由于项目所有人都能看见,为了确保其安全性,建议使用ssh连接项目,私钥储存在项目名称/settings/Secrets,公钥在此添加https://github.com/settings/keys 创建密钥对已经创建了的可以跳过这步 若提示git@github.com: Permission denied (publickey)可以删除~/.ssh/id_rsa和~/.ssh/id_rsa.pub后重新创建 ssh-keygen -t rsa -C &quot;邮箱&quot;创建密钥对,一路回车即可 ssh-agent bash ssh-agent -s ssh-add ~/.ssh/id_rsa cat ~/.ssh/id_rsa.pub将其复制并添加到https://github.com/settings/keys 别忘了gitee或coding也需要部署公钥 ssh -T git@github.com验证是否生效,若出现Hi,xxx!You&#39;ve successfully authenticated即代表成功 cat ~/.ssh/id_rsa将所有内容全都复制并添加到项目/settings/Secrets,名称与git sync项目里变量名SSH_PRIVATE_KEY相同 uPicupic仅支持MacOS,如果其他平台有这个需求,可以使用PicGo 从github下载GUI客户端https://github.com/gee1k/uPic 在偏好设置里添加github,并修改其相关配置 GitHub配置 用户名: zhboat 仓库名: cdn_pic Token: github添加token 域名: 可以自定义，如使用cdn加速勾选加速访问即可 保存路径: 默认是upic/文件名.后缀名","categories":[],"tags":[{"name":"github","slug":"github","permalink":"https://zhboat.ink/tags/github/"}]},{"title":"C语言笔记(1)","slug":"C语言笔记-1","date":"2020-03-25T07:28:16.000Z","updated":"2020-11-14T05:12:32.205Z","comments":true,"path":"C语言笔记-1/","link":"","permalink":"https://zhboat.ink/C%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0-1/","excerpt":"if与if判断","text":"if与if判断 基本的if语句由关键字if开头,在括号里的是表示条件的逻辑表达式,在{}之间的若干表达式.如果表示条件的逻辑表达式结果不是零,那么执行后面{}之间的表达式,否则就跳过这些表达式不执行,而继续执行下面的其他语句. if 格式 if&amp;else 12345if (条件判断)&#123; 表达式&#125; else // 否则&#123; 表达式 &#125;// else后的&#123;&#125;可以不需要 if 123if (条件判断)&#123; 表达式&#125;&#x2F;&#x2F; if后的&#123;&#125;也可以不需要 值得注意的是,可以使用if嵌套 计算两个值之间的关系判断叫关系运算/比较运算 运算符 意义 == 相等 != 不相等 &gt; 大于 &gt;= 大于或等于 &lt; 小于 &lt;= 小于或等于 优先级 关系运算符的优先级比算术运算符低,但是比赋值高 123int x = 4 &gt;= 5 + 3; // x = ( 4 &gt;= 8) // x = 0 判断是否相等的==和!=优先级比其他关系运算符低,在连续的关系运算符中,优先级的顺序是自左向右运算. 123455 &gt; 3 == 6 &gt; 4// 1 == 16 &gt; 5 &gt; 4// 6大于5成立,则其值为1// 1 大于4不成立.则其值为0 代码示例 计算找零 12345678910111213141516171819#include &lt;stdio.h&gt;int main() &#123; // 初始化 int price = 0; int bill = 0; // 让用户输入金额和票面 printf(\"请输入金额：\"); scanf(\"%d\", &amp;price); printf(\"请输入票面：\"); scanf(\"%d\", &amp;bill); // 判断,当票面大于或等于金额时,执行找零操作 if ( bill &gt;= price )&#123; printf(\"应当找您：%d\\n\",bill - price); &#125; else&#123; printf(\"您的钱不够\"); &#125; return 0;&#125; 计算年龄 12345678910111213141516171819#include &lt;stdio.h&gt;int main() &#123; // 定义初始值 const int MINOR = 35; // 初始化 int age = 0; // 输入年龄 printf(\"请输入您的年龄：\"); scanf(\"%d\", &amp;age); printf(\"您的年龄是:%d\\n\",age); // 判断 if ( age &lt;= MINOR)&#123; printf(\"年轻是美好的\\n\"); &#125; else&#123; printf(\"年龄决定了您的精神世界，请好好珍惜吧。\\n\"); &#125; return 0;&#125; 比较大小 12345678910111213141516171819#include &lt;stdio.h&gt;int main() &#123; // 定义变量 int a , b; // 输入整数 printf(\"请输入两个整数:\"); scanf(\"%d %d\", &amp;a, &amp;b); // 初始化 int max = 0; // 判断 if ( a &gt; 0 )&#123; max = a; &#125; else&#123; max = b; &#125; printf(\"大的值是%d\\n\",max); return 0;&#125; 而上述代码还可以简写成下面的样子 123456789101112131415161718192021#include &lt;stdio.h&gt;int main() &#123; // 定义变量 int a , b; // 输入整数 printf(\"请输入两个整数:\"); scanf(\"%d %d\", &amp;a, &amp;b); // 初始化 /* *将b的值赋值给max,而后进行判断,当a的值大于max时将a的值赋值给max *而不满足判断时,直接输出max的值(也就是b的值) */ int max = b; // 判断 if ( a &gt; b )&#123; max = a; &#125; printf(\"大的值是%d\\n\",max); return 0;&#125; 计算薪水 12345678910111213141516171819202122232425/* * 按照薪资标准，加班的时间以1.5倍计算 * 当用户输入工作时长后，进行判断，如果大于每周标准工作时长则进行计算：每周的工资+加班时间*1.5倍工资 * 否则计算用户输入工作时长*小时薪资 */#include &lt;stdio.h&gt;int main() &#123; // 定义变量 const double RATE = 8.25; // 每小时8.25块 const int STANDARD = 40; // 一周标准工作时长40小时 double pay = 0.0; int hours; // 输入工作时长 printf(\"请输入工作的小时数:\"); scanf(\"%d\", &amp;hours); // 判断 if ( hours &gt; STANDARD )&#123; pay = STANDARD * RATE + (hours - STANDARD) * (RATE * 1.5); &#125; else&#123; pay = hours * RATE; &#125; printf(\"应付工资：%f\",pay); return 0;&#125; 判断成绩 12345678910111213141516171819#include &lt;stdio.h&gt;int main() &#123; // 定义变量 const int PASS = 60; int source; // 输入成绩 printf(\"请输入成绩:\"); scanf(\"%d\", &amp;source); printf(\"您输入的成绩是%d\\n\",source); // 判断 if ( source &lt; PASS )&#123; printf(\"您的成绩不合格！\"); &#125; else&#123; printf(\"您的成绩是合格的！\"); &#125; printf(\"再见\"); return 0;&#125; if嵌套在嵌套中,if没有{}的情况下,else通常是和最近的if匹配 同时,else不会被代码缩进影响 所以标准写法还是在if和else后加上{},哪怕是只有一条语句 判断大小 1234567891011121314151617181920212223 #include &lt;stdio.h&gt; int main() &#123; int a,b,c; printf(\"请输入任意三个整数:\"); scanf(\"%d %d %d\", &amp;a, &amp;b, &amp;c); int max = 0; if ( a &gt; b ) &#123; if ( a &gt; c )&#123; max = a; &#125; else&#123; max = c ; &#125; &#125; else&#123; if ( b &gt; c )&#123; max = b; &#125; else&#123; max = c; &#125; &#125; printf(\"最大值是：%d\",max); return 0;&#125; 可以简化成下面的样子 12345678910111213141516171819#include &lt;stdio.h&gt;int main() &#123; int a, b, c; printf(\"请输入任意三个整数:\"); scanf(\"%d %d %d\", &amp;a, &amp;b, &amp;c); int max = 0; if (a &gt; b) if (a &gt; c) max = a; else max = c; else if (b &gt; c) max = b; else max = c; printf(\"最大值是：%d\", max); return 0;&#125; 级联判断/分段函数 1234567891011121314151617#include &lt;stdio.h&gt;int main() &#123; int x,f; x = 0; f = 0; scanf(\"%d\", &amp;x); if ( x &lt; 0)&#123; f = -1; &#125; else if ( x == 0)&#123; f = x; &#125; else &#123; f = 2 * x; &#125; printf(\"f=%d\",f); return 0;&#125; switchswitch语句的作用就是基于计算的跳转,当满足表达式的值之后,程序会跳转到对应的case(分支标号)处 但分支标号只是作为switch的标记,在switch内的表达式后面如果没有break作为结束,将会继续执行下一个case内的表达式,直至遇到一个break或整个switch执行完毕 级联与switch 12345678910111213141516#include &lt;stdio.h&gt;int main() &#123; int type; scanf(\"%d\",&amp;type); if ( type == 1)&#123; printf(\"早上好\"); &#125; else if ( type == 2)&#123; printf(\"中午好\"); &#125; else if ( type == 3)&#123; printf(\"晚上好\"); &#125; else&#123; printf(\"再见！\"); &#125; return 0;&#125; 这种代码看上去十分繁琐,使用switch就能轻松实现 switch的语法与if大同小异,而且代码明了高效率 123456789switch (整型变量或表达式)&#123; // xx可以为整型表达式例如1+1,也可以为整型常量 case xx; //表达式; break; case xx; //表达式; break;&#125; 用switch把上面的if转换成简单易懂的风格就是如下 1234567891011121314151617181920#include &lt;stdio.h&gt;int main() &#123; int type; scanf(\"%d\", &amp;type); switch( type )&#123; case 1: printf(\"早上好\"); break; case 2: printf(\"中午好\"); break; case 3: printf(\"晚上好\"); break; default: printf(\"再见!\"); &#125; return 0;&#125; 题目-成绩转换 将百分制成绩转换成五分制成绩,并严格遵循如下转换规则: 大于等于90分为A 小于90且大于等于80为B 小于80且大于等于70为C 小于70且大于等于60为D 小于60为E 输出格式 输入在一行中给出1个整数的百分制成绩 输出格式 在一行中输出对应的五分制成绩 输入样例 90 输出样例 A 解题思路:除了级联if嵌套以外,还可以使用switch来判断并输出,碍于需要判断大小于,所以可以将输入的整数进行/10的操作,只取前1位有效数作为变量,实现代码如下 123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;int main() &#123; int score; scanf(\"%d\", &amp;score); // 成绩取一位有效数 score /=10; switch (score)&#123; case 10: case 9: printf(\"A\"); break; case 8: printf(\"B\"); break; case 7: printf(\"C\"); break; case 6: printf(\"D\"); break; default: printf(\"E\"); break; &#125; return 0;&#125; 如此,便满足了题目要求","categories":[],"tags":[{"name":"C","slug":"C","permalink":"https://zhboat.ink/tags/C/"}]},{"title":"Arch入教手册","slug":"Arch入教手册","date":"2020-03-14T16:00:00.000Z","updated":"2020-11-14T05:12:32.205Z","comments":true,"path":"Arch入教手册/","link":"","permalink":"https://zhboat.ink/Arch%E5%85%A5%E6%95%99%E6%89%8B%E5%86%8C/","excerpt":"记录Arch的安装过程","text":"记录Arch的安装过程 1. 准备刻录U盘 从网易源或阿里源下载archlinux镜像，使用Etcher来刻录镜像到U盘 到BIOS修改启动顺序，将U盘设置成首位 连接网络 使用ip link查看网卡网络连接情况 开启网卡ip link set 网卡名 up 图形化的WiFi连接界面wifi-menu 给有线网卡分配IPdhcpcd 修改软件源 修改pacman源，vim /etc/pacman.d/mirrorlist 只保留网易源(也可以选择其他的)，在vim界面输入[:v/163/d]，回车后输入[:x]保存退出 分区 查看分区表fdisk -l 给sd*磁盘分区parted /dev/sd* 创建分区表 UEFI/GPT:(parted) mklabel gpt BIOS/MBR:(parted) mklabel msdos 分区 UEFI/GPT: 创建EFI分区(parted) mkpart ESP fat32 1M 300M 创建Swap分区(parted) mkpart primary linux-swap 300M 8.9G 创建/分区(parted) mkpart primary ext4 8.9G 100% BIOS/MBR: 创建Swap分区(parted) mkpart primary linux-swap 1M 8G 创建/分区(parted) mkpart primary ext4 8G 100% 挂载分区 UEFI/GPT 格式化efi分区mkfs.fat -F32 /dev/sd** 格式化swap分区mkswap /dev/sd** 开启swap分区swapon /dev/sd** 格式化/分区mkfs.ext4 /dev/sd** 挂载/分区mount /dev/sd** /mnt 创建efi文件夹mkdir -p /mnt/boot/efi 挂载efi分区mount /dev/sd** /mnt/boot/efi BIOS/MBR: 格式化swap分区mkswap /dev/sd** 开启swap分区swapon /dev/sd** 格式化/分区mkfs.ext4 /dev/sd** 挂载/分区mount /dev/sd** /mnt 2. 安装安装 使用脚本安装系统必要软件包pacstrap /mnt base linux linux-firmware fstab 生成fstabgenfstab -U /mnt &gt;&gt; /mnt/etc/fstab 查看fstab是否正确被写入cat /mnt/etc/fstab 配置切换进Archarch-chroot /mnt 安装软件包一键安装必要软件包vi,vim,网络管理器,Intel核显,sudo,ssh服务, 1paman -S vi vim networkmanager dhcpcd intel-ucode sudo openssh 时区&amp;时间 设置时区ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime 开启NTP服务timedatectl set-ntp true 设定硬件时间为UTChwclock --systohc 语言 编辑locale.genvim /etc/locale.gen 删除en_US.UTF-8 UTF-8,zh_CN.UTF-8 UTF-8,zh_TW.UTF-8 UTF-8前面的# 生成locale信息locale-gen 将系统语言设置成en_US.UTF-8echo &quot;LANG=en_US.UTF-8&quot; &gt;&gt; /etc/locale.conf,并检查是否有误cat /etc/locale.conf 主机名 修改主机名echo &quot;urname&quot; &gt;&gt; /etc/hostname 修改hostsvim /etc/hosts 123127.0.0.1 localhost::1 localhost127.0.1.1 urname.localdomain urname 用户 添加一个普通用户useradd -m -g users -G wheel -s /bin/bash urname 修改root用户和刚刚创建的普通用户密码passwd root,passwd urname 普通用户使用sudo命令无需输入密码visudo删除# %wheel ALL=(ALL) ALL前的# Grub引导 安装grub UEFI/GPT: 安装grub和efibootmgr软件包pacman -S grub efibootmgr 安装grub进efi分区 1grub-install --target=x86_64-efi --efi-directory=/boot/efi --bootloader-id=grub 生成grub所需文件grub-mkconfig -o /boot/grub/grub.cfg BIOS/MBR: 安装grub软件包pacman -S grub 安装grub到磁盘中grub-install –target=i386-pc /dev/sd*` 生成grub所需文件grub-mkconfig -o /boot/grub/grub.cfg 结束第一部分安装exit回到live环境,卸载已挂载的分区umount -R /mnt就能重启了reboot 3. 后续网络 开启NetworkManager服务systemctl start NetworkManager,并设置成开机自启systemctl enable NetworkManager 查看附近的WiFinmcli dev wifi 连接WiFi nmcli dev wifi con wifi名 password WiFi密码(dev是简写的device,con是简写的connect) 桌面环境安装xorg相关服务pacman -S xorg xorg-server xorg-xinit Deepin安装deepin,附加组件可以安装deepin-extrapacman -S deepin 启用deepin桌面systemctl enable lightdm &amp;&amp; systemctl start lightdm 从官网偷的图:P Gnome安装gnome,附加组件可以安装gnome-extra,包含一些游戏等,还可以安装美化工具gnome-tweakspacman -S gnome 启用gnome桌面systemctl enable gdm &amp;&amp; systemctl enable gdm 4. 其他sshssh的坑 不能直接连接,修改/etc/ssh/sshd_config,然后重启ssh服务systemctl restart sshd 123LoginGraceTime 120PermitRootLogin yesStrictModes yes 未完待续…","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://zhboat.ink/tags/Linux/"},{"name":"Arch","slug":"Arch","permalink":"https://zhboat.ink/tags/Arch/"}]}],"categories":[],"tags":[{"name":"日常","slug":"日常","permalink":"https://zhboat.ink/tags/%E6%97%A5%E5%B8%B8/"},{"name":"Python","slug":"Python","permalink":"https://zhboat.ink/tags/Python/"},{"name":"C","slug":"C","permalink":"https://zhboat.ink/tags/C/"},{"name":"黑苹果","slug":"黑苹果","permalink":"https://zhboat.ink/tags/%E9%BB%91%E8%8B%B9%E6%9E%9C/"},{"name":"github","slug":"github","permalink":"https://zhboat.ink/tags/github/"},{"name":"hexo","slug":"hexo","permalink":"https://zhboat.ink/tags/hexo/"},{"name":"Linux","slug":"Linux","permalink":"https://zhboat.ink/tags/Linux/"},{"name":"Arch","slug":"Arch","permalink":"https://zhboat.ink/tags/Arch/"}]}